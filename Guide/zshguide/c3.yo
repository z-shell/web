COMMENT(-- $Id$ --)\
lchapter(syntax)(Dealing with basic shell syntax)

This chapter is a more thorough examination of much of what appeared in the
lref(chapter)(init); to be more specific, I assume you're sitting in
front of your terminal about to use the features you just set up in your
initialisation files and want to know enough to get them going.
Actually, you will probably spend most of the time editing command lines
and in particular completing commands --- both of these activities are
covered in later chapters.  For now I'm going to talk about commands and
the syntax that goes along with using them.  This will let you write
shell functions and scripts to do more of your work for you.

In the following there are often several consecutive paragraphs
about quite minor features.  If you find you read this all through the
first time, maybe you need to get out more.  Most people will probably find
it better to skim through to find what the subject matter is, then come
back if they later find they want to know more about a particular aspect of
the shell's commands and syntax.

One aspect of the syntax is left to lref(chapter)(subst): there's just so
much to it, and it can be so useful if you know enough to get it right,
that it can't all be squashed in here.  The subject is expansion, covering
a multitude of things such as parameter expansion, globbing and history
expansions.  You've already met the basics of these in lref(chapter)(init);
but if you want to know how to pick a particular file with a globbing
expression with pinpoint accuracy, or how to make a single parameter
expansion reduce a long expression to the words you need, you should read
that chapter; it's more or less self-contained, so you don't necessarily
need to know everything in this one.

We start with the most basic issue in any command line interpreter,
running commands.  As you know, you just type words separated by spaces,
where the first word is a command and the remainder are arguments to it.
It's important to distinguish between the types of command.

sect(External commands)

External commands are the easiest, because they have the least interaction
with the shell --- many of the commands provided by the shell itself,
which are described in the next section, are built into the shell especially
to avoid this difficulty.

The only major issue is therefore how to find them.  This is done through
the parameters tt($path) and tt($PATH), which, as I described in
lref(chapter)(init), are tied together because although the first one is
more useful inside the shell --- being an array, its various parts can
be manipulated separately --- the second is the one that is used by
other commands called by the shell; in the jargon, tt($PATH) is
`exported to the environment', which means exactly that other commands
called by the shell can see its value.

So suppose your tt($path) contains
verb(  /home/pws/bin /usr/local/bin /bin /usr/bin)
and you try to run `tt(ls)'.  The shell first looks in tt(/home/pws/bin)
for a command called tt(ls), then in tt(/usr/local/bin), then in tt(/bin),
where it finds it, so it executes tt(/bin/ls).  Actually, the operating
system itself knows about paths if you execute a command the right way, so
the shell doesn't strictly need to.

There is a subtlety here.  The shell tries to remember where the commands
are, so it can find them again the next time.  It keeps them in a so-called
`hash table', and you find the word `hash' all over the place in the
documentation: all it means is a fast way of finding some value, given a
particular key.  In this case, given the name of a command, the shell can
find the path to it quickly.  You can see this table, in the form
`var(key)tt(=)var(value)', by typing `tt(hash)'.

In fact the shell only does this when the option tt(HASH_CMDS) is set, as
it is by default.  As you might expect, it stops searching when it finds
the directory with the command it's looking for.  There is an extra
optimisation in the option tt(HASH_ALL), also set by default: when the
shell scans a directory to find a command, it will add all the other
commands in that directory to the hash table.  This is sensible because on
most UNIX-like operating systems reading a whole lot of files in the same
directory is quite fast.

The way commands are stored has other consequences.  In particular, zsh
won't look for a new command if it already knows where to find one.  If I
put a new tt(ls) command in tt(/usr/local/bin) in the above example, zsh
would continue to use tt(/bin/ls) (assuming it had already been found).  To
fix this, there is the command tt(rehash), which actually empties the
command hash table, so that finding commands starts again from scratch.
Users of csh may remember having to type tt(rehash) quite a lot with new
commands: it's not so bad in zsh, because if no command was already hashed,
or the existing one disappeared, zsh will automatically scan the path
again; furthermore, zsh performs a tt(rehash) of its own accord if
tt($path) is altered.  So adding a new duplicate command somewhere towards
the head of tt($path) is the main reason for needing tt(rehash).

One thing that can happen if zsh hasn't filled its command hash table and
so doesn't know about all external commands is that the tt(AUTO_CD) option,
mentioned in the previous chapter and again below, can think you are trying
to change to a particular directory with the same name as the command.
This is one of the drawbacks of tt(AUTO_CD).

To be a little bit more technical, it's actually not so obvious that
command hashing is needed at all; many modern operating systems can find
commands quickly without it.  The clincher in the case of zsh is that the
same hash table is necessary for command completion, a very commonly used
feature.  If you type `tt(compr<TAB>)', the shell completes this to
`tt(compress)'.  It can only do this if it has a list of commands to
complete, and this is the hash table.  (In this case it didn't need to know
where to find the command, just its name, but it's only a little extra work
to store that too.)  If you were following the previous paragraphs, you'll
realise zsh doesn't necessarily know em(all) the possible commands at the
time you hit tt(TAB), because it only looks when it needs to.  For this
purpose, there is another option, tt(HASH_LIST_ALL), again set by default,
which will make sure the command hash table is full when you try to
complete a command.  It only needs to do this once (unless you alter
tt($path)), but it does mean the first command completion is slow.  If
tt(HASH_LIST_ALL) is not set, command completion is not available:  the
shell could be rewritten to search the path laboriously every single time
you try to complete a command name, but it just doesn't seem worth it.

The fact that tt($PATH) is passed on from the shell to commands called from
it (strictly only if the variable is marked for export, as it usually is
--- this is described in more detail with the tt(typeset) family of builtin
commands below) also has consequences.  Some commands call subcommands of
their own using tt($PATH).  If you have that set to something unusual, so
that some of the standard commands can't be found, it could happen that a
command which em(is) found nonetheless doesn't run properly because it's
searching for something it can't find in the path passed down to it.  That
can lead to some strange and confusing error messages.

One important thing to remember about external commands is that the shell
continues to exist while they are running; it just hangs around doing
nothing, waiting for the job to finish (though you can tell it not to, as
we'll see).  The command is given a completely new environment in which to
run; changes in that don't affect the shell, which simply starts up where
it left off after the command has run.  So if you need to do something
which changes the state of the shell, an external command isn't good
enough.  This brings us to builtin commands.

sect(Builtin commands)

Builtin commands, or builtins for short, are commands which are part of the
shell itself.  Since builtins are necessary for controlling the shell's own
behaviour, introducing them actually serves as an introduction to quite
a lot of what is going on in the shell.  So a fair fraction of what
would otherwise appear later in the chapter has accumulated here, one way
or another.  This does make things a little tricksy in places; count how
many times I use the word `tt(subtle)' and keep it for your grandchildren
to see.

I just described one reason for builtins, but there's a simpler one: speed.
Going through the process of setting up an entirely new environment for the
command at the beginning, swapping between this command and anything else
which is being run on the computer, then destroying it again at the end is
considerable overkill if all you want to do is, say, print out a message on
the screen.  So there are builtins for this sort of thing.

subsect(Builtins for printing)

The commands `tt(echo)' and `tt(print)' are shell builtins; they just show
what you typed, after the shell has removed all the quoting.  The
difference between the two is really historical: `tt(echo)' came first, and
only handled a few simple options; ksh provided `tt(print)', which had more
complex options and so became a different command.  The difference remains
between the two commands in zsh; if you want wacky effects, you should look
to tt(print).  Note that there is usually also an external command called
tt(echo), which may not be identical to zsh's; there is no standard
external command called tt(print), but if someone has installed one on your
system, the chances are it sends something to the printer, not the screen.

One special effect is `tt(print -z)' puts the arguments onto the editing
buffer stack, a list maintained by the shell of things you are about to
edit.  Try:
verb(  print -z print -z print This is a line)
(it may look as if something needs quoting, but it doesn't)
and hit return three times.  The first time caused everything after the
first `tt(print -z)' to appear for you to edit, and so on.

For something more useful, you can write functions that give you a line to
edit:
verb(  fn() { print -z print The time now is $(date); })
Now when you type `tt(fn)', the line with the date appears on the command
line for you to edit.  The option `tt(-s)' is a bit similar; the line
appears in the history list, so you will see it if you use up-arrow, but
it doesn't reappear automatically.

A few other useful options, some of which you've already seen, are
description(
  mydit(tt(-r)) don't interpret special character sequences like `tt(\n)'
  mydit(tt(-P)) use `tt(%)' as in prompts
  mydit(tt(-n)) don't put a newline at the end in case there's
    more output to follow
  mydit(tt(-c)) print the output in columns --- this means
    that `tt(print -c *)' has the effect of a sort of poor person's
    `tt(ls)', only faster
  mydit(tt(-l)) use one line per argument instead of one column,
    which is sometimes useful for sticking lists into files, and for
    working out what part of an array parameter is in each element.
)

If you don't use the tt(-r) option, there are a whole lot of special
character sequences.  Many of these may be familiar to you from C.
description(
  mydit(tt(\n)) newline
  mydit(tt(\t)) tab
  mydit(tt(\e) or tt(\E)) escape character
  mydit(tt(\a)) ring the bell (alarm), usually a euphemism for a hideous
    beep
  mydit(tt(\b)) move back one character.
  mydit(tt(\c)) don't print a newline --- like the tt(-n) option, but
    embedded in the string.  This alternative comes from Berkeley UNIX.
  mydit(tt(\f)) form feed, the phrase for `advance to next page' from the
    days when terminals were called teletypes, maybe more familiar to you
    as tt(^L)
  mydit(tt(\r)) carriage return --- when printed, the annoying tt(^M)'s
    you get in DOS files, but actually rather useful with `tt(print)',
    since it will erase everything to the start of the line.  The
    combination of the tt(-n) option and a tt(\r) at the start of the
    print string can give the illusion of a continuously changing status
    line.
  mydit(tt(\v)) vertical tab, which I for one have never used (I just tried
    it now and it behaved like a newline, only without assuming a carriage
    return, but that's up to your terminal).
)
In fact, you can get any of the 255 characters possible, although your
terminal may not like some or all of the ones above 127, by specifying a
number after the backslash.  Normally this consists of three octal
characters, but you can use two hexadecimal characters after tt(\x) instead
--- so `tt(\n)', `tt(\012)' and `tt(\x0a)' are all newlines.  `tt(\)'
itself escapes any other character, i.e. they appear as themselves even if
they normally wouldn't.

Two notes: first, don't get confused because `tt(n)' is the fourteenth
letter of the alphabet; printing `tt(\016)' (fourteen in octal) won't do
you any good.  The remedy, after you discover your text is unreadable (for
VT100-like terminals including xterm), is to print `tt(\017)'.

Secondly, those backslashes can land you in real quoting difficulties.
Normally a backslash on the command line escapes the next character ---
this is a em(different) form of escaping to tt(print)'s --- so
verb(  print \n)
doesn't produce a newline, it just prints out an `tt(n)'.  So you need to
quote that.  This means
verb(  print \\)
passes a single backslash to quote, and
verb(  print \\n)
or
verb(  print '\n')
prints a newline (followed by the extra one that's usually there).  To
print a real backslash, you would thus need
verb(  print \\\\)
Actually, you can get away with the two if there's nothing else after ---
tt(print) just shrugs its shoulders and outputs what it's been given --- but
that's not a good habit to get into.  There are other ways of doing this:
since single quotes quote anything, including backslashes (they are the
only way of making backslashes behave like normal characters), and since
the `tt(-r)' option makes print treat characters normally,
verb(  print -r '\')
has the same effect.  But you need to remember the two levels of quoting
for backslashes.  Quotes aren't special to tt(print), so
verb(  print \')
is good enough for printing a quote.

nsubsubsect(tt(echotc))

There's an oddity called `tt(echotc)', which takes as its argument
`termcap' capabilities.  This now lives in its own module,
tt(zsh/termcap).

Termcap is a now rather old-fashioned way of giving the commands
necessary for performing various standard operations on terminals:
moving the cursor, clearing to the end of the line, turning on standout
mode, and so on.  It has now been replaced almost everywhere by
`terminfo', a completely different way of specifying capabilities, and
by `curses', a more advanced system for manipulating objects on a
character terminal.  This means that the arguments you need to give to
tt(echotc) can be rather hard to come by; try the tt(termcap) manual
page; if there are two, it's probably the one in section five which
gives the codes, i.e. `tt(man 5 zsh)' or `tt(man -s 5 zsh)' on Solaris.
Otherwise you'll have to search the web.  The reason the tt(zsh) manual
doesn't give a list is that the shell only uses a few well-known
sequences, and there are very many others which will work with
tt(echotc), because the sequences are interpreted by a the terminal, not
the shell.

This chunk gives you a flavour:
verb(  zmodload -i zsh/termcap
  echotc md
  echo -n bold
  echotc mr
  echo -n reverse
  echotc me
  echo)
First we make sure the module is loaded into the shell; on some
older operating systems, this only works if it was compiled in when zsh
was installed.  The option tt(-i) to tt(zmodload) stops the shell from
complaining if the module was already loaded.  This is a sensible way of
ensuring you have the right facilities available in a shell function,
since loading a module makes it available until it is explicitly
unloaded.

You should see `tt(bold)' in bold characters, and `tt(reverse)' in bold
reverse video.  The `tt(md)' capability turns on bold mode; `tt(mr)' turns
on reverse video; `tt(me)' turns off both modes.  A more typical zsh way of
doing this is:
verb(  print -P '%Bbold%Sreverse%b%s')
which should show the same thing, but using prompt escapes --- prompts are
the most common use of special fonts.  The `tt(%S)' is because zsh calls
reverse `standout' mode, because it does.  (On a colour xterm, you may find
`bold' is interpreted as `blue'.)

There's a lot more you can do with tt(echotc) if you really try.  The shell
has just acquired a way of printing terminfo sequences, predictably called
tt(echoti), although it's only available on systems where zsh needs
terminfo to compile --- this happens when the termcap code is actually a
part of terminfo.  The good news about this is that terminfo tends to be
better documented, so you have a good chance of finding out the
capabilities you want from the tt(terminfo) manual page.  The tt(echoti)
command lives in another predictably named module, tt(zsh/terminfo).

subsect(Other builtins just for speed)

There are only a few other builtins which are there just to make things go
faster.  Strictly, tests could go into this category, but as I explained in
the last chapter it's useful to have tests in the form
verb(  if [[ $var1 = $var2 ]]; then
    print doing something
  fi)
be treated as a special syntax by the shell, in case tt($var1) or tt($var2)
expands to nothing which would otherwise confuse it.  This example
consists of two features described below:  the test itself, between the
double square brackets, which is true if the two substituted values are the
same string, and the `tt(if)' construct which runs the commands in the
middle (here just the tt(print)) if that test was true.

The builtins `tt(true)' and `tt(false)' do nothing at all, except return a
command status zero or one, respectively.  They're just used as
placeholders:  to run a loop forever --- tt(while) will also be explained
in more detail later --- you use
verb(  while true; do
    print doing something over and over
  done)
since the test always succeeds.

A synonym for `tt(true)' is `tt(:)'; it's often used in this form to give
arguments which have side effects but which shouldn't be used --- something
like
verb(  : ${param:=value})
which is a common idiom in all Bourne shell derivatives.  In the parameter
expansion, tt($param) is given the value tt(value) if it was empty before,
and left alone otherwise.  Since that was the only reason for the
parameter expansion, you use tt(:) to ignore the argument.  Actually, the
shell blithely builds the command line --- the colon, followed by whatever
the value of tt($param) is, whether or not the assignment happened --- then
executes the command; it just so happens that `tt(:)' takes no notice of
the arguments it was given.  If you're switching from ksh, you may expect
certain synonyms like this to be aliases, rather than builtins themselves,
but in zsh they are actually builtins; there are no aliases predefined by
the shell.  (You can still get rid of them using `tt(disable)', as
described below.)

subsect(Builtins which change the shell's state)

A more common use for builtins is that they change something inside the
shell, or report information about what's going on in the shell.  There is
one vital thing to remember about external commands.  It applies, too, to
other cases we'll meet where the shell `forks', literally splitting itself
into two parts, where the forked-off part behaves just like an external
command.  In both of these cases, the command is in a different em(process),
UNIX's basic unit of things that run.  (In fact, even Windows knows about
processes nowadays, although they interact a little bit differently with
one another.)

The vital thing is that no change in a separate process started by the
shell affects the shell itself.  The most common case of this is the
current directory --- every process has its own current directory.  You can
see this by starting a new zsh:
verb(  % pwd               # show the current directory
  ~
  % zsh               # start a new shell, which 
                      # is a separate process
  % cd tmp
  % pwd               # now I'm in a different
                      # directory...
  ~/tmp
  % exit              # leave the new shell...
  % pwd               # now I'm back where I was...
  ~)
Hence the tt(cd) command must be a shell builtin, or this would happen
every time you ran it.

Here's a more useful example.  Putting parentheses around a command asks
the shell to start a different process for it.  That's useful when you
specifically em(don't) want the effects propagating back:
verb(  (cd some-other-dir; run-some-command))
runs the command, but doesn't change the directory the `real' shell is in,
only its forked-off `subshell'.  Hence,
verb(  % pwd
  ~
  % (cd /; pwd)
  /
  % pwd
  ~)

There's a more subtle case:
verb(  cd some-other-dir | print Hello)
Remember, the `tt(|)' (`pipe') connects the output of the first command to
the input of the next --- though actually no information is passed that way
in this example.  In zsh, all but the last portion of the `pipeline'
thus created is run in different processes.  Hence the tt(cd) doesn't
affect the main shell.  I'll refer to it as the `parent' shell, which is
the standard UNIX language for processes; when you start another command or
fork off a subshell, you are creating `children' (without meaning to be
morbid, the children usually die first in this case).  Thus, as you would
guess,
verb(  print Hello | cd some-other-dir)
em(does) have the effect of changing the directory.  Note that other
shells do this differently; it is always guaranteed to work this way in
zsh, because many people rely on it for setting parameters, but many
shells have the em(left) hand of the pipeline being the bit that runs
in the parent shell.  If both sides of the pipe symbol are external
commands of some sort, both will of course run in subprocesses.

There are other ways you change the state of the shell, for example by
declaring parameters of a particular type, or by telling it how to
interpret certain commands, or, of course, by changing options.  Here are
the most useful, grouped in a vaguely logical fashion.

subsect(cd and friends)

You will not by now be surprised to learn that the `tt(cd)' command changes
directory.  There is a synonym, `tt(chdir)', which as far as I know no-one
ever uses.  (It's the same name as the system call, so if you had been
programming in C or Perl and forgot that you were now using the shell,
you might use `tt(chdir)'.  But that seems a bit far-fetched.)

There are various extra features built into tt(cd) and tt(chdir).  First,
if you miss out the directory to which you want to change, you will be
taken to your home directory, although it's not as if `tt(cd ~)' is all
that hard to type.

Next, the command `tt(cd -)' is special:  it takes you to the last
directory you were in.  If you do a sequence of tt(cd) commands, only the
immediately preceding directory is remembered; they are not stacked up.

Thirdly, there is a shortcut for changing between similarly named
directories.  If you type `tt(cd <old> <new>)', then the shell will look
for the first occurrence of the string `tt(<old>)' in the current directory,
and try to replace it with `tt(<new>)'.  For example,
verb(  % pwd
  ~/src/zsh-3.0.8/Src
  % cd 0.8 1.9
  ~/src/zsh-3.1.9/Src)
The tt(cd) command actually reported the new directory, as it usually does
if it's not entirely obvious where it's taken you.

Note that only the em(first) match of tt(<old>) is taken.  It's an easy
mistake to think you can change from tt(/home/export1/pws/mydir1/something)
to tt(/home/export1/pws/mydir2/something) with `tt(cd 1 2)', but that first
`tt(1)' messes it up.  Arguably the shell could be smarter here.  Of
course, `tt(cd r1 r2)' will work in this case.

tt(cd)'s friend `tt(pwd)' (print working directory) tells you what the
current working directory is; this information is also available in the
shell parameter tt($PWD), which is special and automatically updated when
the directory changes.  Later, when you know all about expansion, you will
find that you can do tricks with this to refer to other directories.
For example, tt(${PWD/old/new}) uses the parameter substitution mechanism
to refer to a different directory with tt(old) replaced by tt(new) --- and
this time tt(old) can be a pattern, i.e. something with wildcard matches in
it.  So if you are in the tt(zsh-3.0.8/Src) directory as above and want to
copy a file from the tt(zsh-3.1.9/Src) directory, you have a shorthand:
verb(  cp ${PWD/0.8/1.9}/myfile.c .)

nsubsubsect(Symbolic links)

Zsh tries to track directories across symbolic links.  If you're not
familiar with these, you can think of them as a filename which behaves like
a pointer to another file (a little like Windows' shortcuts, though UNIX
has had them for much longer and they work better).  You create them like
this (tt(ln) is not a builtin command, but its use to make symbolic links
is very standard these days):
verb(  ln -s existing-file-name name-of-link)
for example
verb(  ln -s /usr/bin/ln ln)
creates a file called tt(ln) in the current directory which does nothing
but point to the file tt(/usr/bin/ln).  Symbolic links are very good
at behaving as much like the original file as you usually want; for
example, you can run the tt(ln) link you've just created as if it were
tt(/usr/bin/ln).  They show up differently in a long file listing with
`tt(ls -l)', the last column showing the file they point to.

You can make them point to any sort of file at all, including directories,
and that is why they are mentioned here.  Suppose you create a symbolic
link from your home directory to the root directory and change into it:
verb(  ln -s / ~/mylink
  cd ~/mylink)
If you don't know it's a link, you expect to be able to change to the
parent directory by doing `tt(cd ..)'.  However, the operating system ---
which just has one set of directories starting from tt(/) and going down,
and ignores symbolic links after it has followed them, they really are
just pointers --- thinks you are in the root directory tt(/).  This can be
confusing.  Hence zsh tries to keep track of where em(you) probably think
you are, rather than where the system does.  If you type `tt(pwd)', you
will see `tt(/home/you/mylink)' (wherever your home directory is), not
`tt(/)'; if you type `tt(cd ..)', you will find yourself back in your home
directory.

You can turn all this second-guessing off by setting the option
tt(CHASE_LINKS); then `tt(cd ~/mydir; pwd)' will show you to be in tt(/),
where changing to the parent directory has no effect; the parent of the
root directory is the root directory, except on certain slightly
psychedelic networked file systems.  This does have advantages: for
example, `tt(cd ~/mydir; ls ..)' always lists the root directory, not your
home directory, regardless of the option setting, because tt(ls) doesn't
know about the links you followed, only zsh does, and it treats the tt(..)
as referring to the root directory.  Having tt(CHASE_LINKS) set allows
`tt(pwd)' to warn you about where the system thinks you are.

An aside for non-UNIX-experts (over 99.9% of the population of the world
at the last count): I said `symbolic links' instead of just `links' because
there are others called `hard links'.  This is what `tt(ln)' creates if you
don't use the tt(-s) option.  A hard link is not so much a pointer to a
file as an alternative name for a file.  If you do
verb(  ln myfile othername
  ls -l)
where tt(myfile) already exists you can't tell which of tt(myfile) and
tt(othername) is the original --- and in fact the system doesn't care.  You
can remove either, and the other will be perfectly happy as the name for
the file.  This is pretty much how renaming files works, except that
creating the hard link is done for you in that case.  Hard links have
limitations --- you can't link to directories, or to a file on another disk
partition (and if you don't know what a disk partition is, you'll see what
a limitation that can be).  Furthermore, you usually want to know which is
the original and which is the link --- so for most users, creating symbolic
links is more useful.  The only drawback is that following the pointers is
a tiny bit slower; if you think you can notice the difference, you
definitely ought to slow down a bit.

The target of a symbolic link, unlike a hard link, doesn't actually have to
exist and no checking is performed until you try to use the link.  The best
thing to do is to run `tt(ls -lL)' when you create the link; the tt(-L)
part tells tt(ls) to follow links, and if it worked you should see that
your link is shown as having exactly the same characteristics as the file
it points to.  If it is still shown as a link, there was no such file.

While I'm at it, I should point out one slight oddity with symbolic links:
the name of the file linked to (the first name), if it is not an absolute
path (beginning with tt(/) after any tt(~) expansion), is treated relative
to the directory where the link is created --- not the current directory
when you run tt(ln).  Here:
verb(  ln -s ../mydir ~/links/otherdir)
the link tt(otherdir) will refer to tt(mydir) in em(its own) parent
directory, i.e. tt(~/links) --- not, as you might think, the parent of the
directory where you were when you ran the command.  What makes it worse is
that the second word, if is not an absolute path, em(is) interpreted
relative to the directory where you ran the command.

nsubsubsect($cdpath and AUTO_CD)

We're nowhere near the end of the magic you can do with directories yet
(and, in fact, I haven't even got to the zsh-specific parts).  The next
trick is tt($cdpath) and tt($CDPATH).  They look a lot like tt($path) and
tt($PATH) which you met in the last chapter, and I mentioned them briefly
back in the last chapter in that context:  tt($cdpath) is an array of
directories, while tt($CDPATH) is colon-separated list behaving otherwise
like a scalar variable.  They give a list of directories whose
subdirectories you may want to change into.  If you use a normal cd command
(i.e. in the form `tt(cd )var(dirname)', and var(dirname) does not begin with
a tt(/) or tt(~), the shell will look through the directories in
tt($cdpath) to find one which contains the subdirectory var(dirname).
If tt($cdpath) isn't set, as you'd guess, it just uses the current
directory.

Note that tt($cdpath) is always searched in order, and you can put a tt(.)
in it to represent the current directory.  If you do, the current directory
will always be searched em(at that point), not necessarily first, which may
not be what you expect.  For example, let's set up some directories:
verb(  mkdir ~/crick ~/crick/dna
  mkdir ~/watson ~/watson/dna
  cdpath=(~/crick .)
  cd ~/watson
  cd dna)
So I've moved to the directory tt(~/watson), which contains the
subdirectory tt(dna), and done `tt(cd dna)'.  But because of tt($cdpath),
the shell will look first in tt(~/crick), and find the tt(dna) there, and
take you to that copy of the self-reproducing directory, not the one in
tt(~/watson).  Most people have tt(.) at the start of their tt(cdpath) for
that reason.  However, at least tt(cd) warns you --- if you tried it, you
will see that it prints the name of the directory it's picked in cases like
this.

In fact, if you don't have tt(.) in your directory at all, the shell will
always look there first; there's no way of making tt(cd) never change to
a subdirectory of the current one, short of turning tt(cd) into a
function.  Some shells don't do this; they use the directories in
tt($cdpath), and only those.

There's yet another shorthand, this time specific to zsh: the option
tt(AUTO_CD) which I mentioned in the last chapter.  That way a command
without any arguments which is really a directory will take you to that
directory.  Normally that's perfect --- you would just get a `command not
found' message otherwise, and you might as well make use of the option.
Just occasionally, however, the name of a directory clashes with the name
of a command, builtin or external, or a shell function, and then there can
be some confusion:  zsh will always pick the command as long as it knows
about it, but there are cases where it doesn't, as I described above.

What I didn't say in the last chapter is that tt(AUTO_CD) respects
tt($cdpath); in fact, it really is implemented so that `var(dirname)' on
its own behaves as much like `tt(cd) var(dirname)' as is possible without
tying the shell's insides into knots.

nsubsubsect(The directory stack)

One very useful facility that zsh inherited from the C-shell family
(traditional Korn shell doesn't have it) is the directory stack.  This is a
list of directories you have recently been in.  If you use the command
`tt(pushd)' instead of `tt(cd)', e.g. `tt(pushd) var(dirname)', then the
directory you are in is saved in this list, and you are taken to
var(dirname), using tt($CDPATH) just as tt(cd) does.  Then when you type
`tt(popd)', you are taken back to where you were.  The list can be as long
as you like; you can tt(pushd) any number of directories, and each tt(popd)
will take you back through the list (this is how a `stack', or more
precisely a `last-in-first-out' stack usually operates in computer jargon,
hence the name `directory stack').

You can see the list --- which always starts with the current
directory --- with the tt(dirs) command.  So, for example:
verb(  cd ~
  pushd ~/src
  pushd ~/zsh
  dirs)
displays
verb(  ~/zsh ~/src ~)
and the next tt(popd) will take you back to tt(~/src).  If you do it, you
will see that tt(pushd) reports the list given by tt(dirs) automatically as
it goes along; you can turn this off with the option tt(PUSHD_SILENT), when
you will have to rely on typing tt(dirs) explicitly.

In fact, a lot of the use of this comes not from using simple tt(pushd) and
tt(popd) combinations, but from two other features.  First, `tt(pushd)' on
its own swaps the top two directories on the stack.  Second, tt(pushd) with
a numeric argument preceded by a `tt(+)' or `tt(-)' can take you to one of
the other directories in the list.  The command `tt(dirs -v)' tells you the
numbers you need; tt(0) is the current directory.  So if you get,
verb(  0       ~/zsh
  1       ~/src
  2       ~)
then `tt(pushd +2)' takes you to tt(~).  (A little suspension of disbelief
that I didn't just use tt(AUTO_CD) and type `tt(..)' is required here.)
If you use a tt(-), it counts from the other end of the list; tt(-0) (with
apologies to the numerate) is the last item, i.e. the same as tt(~) in this
case.  Some people are used to having the `tt(-)' and `tt(+)'
arguments behave the other way around; the option tt(PUSHD_MINUS) exists
for this.

Apart from tt(PUSHD_SILENT) and tt(PUSHD_MINUS), there are a few other
relevant options.  Setting tt(PUSHD_IGNORE_DUPS) means that if you
tt(pushd) to a directory which is already somewhere in the list, the
duplicate entry will be silently removed.  This is useful for most human
operations --- however, if you are using tt(pushd) in a function or script
to remember previous directories for a future matching tt(popd), this can
be dangerous and you probably want to turn it off locally inside the
function.

tt(AUTO_PUSHD) means that any directory-changing command, including an
auto-cd, is treated as a tt(pushd) command with the target directory as
argument.  Using this can make the directory stack get very long, and there
is a parameter tt($DIRSTACKSIZE) which you can set to specify a maximum
length.  The oldest entry (the highest number in the `tt(dirs -v)' listing)
is automatically removed when this length is exceeded.  There is no limit
unless this is explicitly set.

The final tt(pushd) option is tt(PUSHD_TO_HOME).  This makes tt(pushd) on
its own behave like tt(cd) on its own in that it takes you to your home
directory, instead of swapping the top two directories.  Normally a series
of `tt(pushd)' commands works pretty much like a series of `tt(cd -)'
commands, always taking you the directory you were in before, with the
obvious difference that `tt(cd -)' doesn't consult the directory stack, it
just remembers the previous directory automatically, and hence it can
confuse tt(pushd) if you just use `tt(cd -)' instead.

There's one remaining subtlety with tt(pushd), and that is what happens to
the rest of the list when you bring a particular directory to the front
with something like `tt(pushd +2)'.  Normally the list is simply cycled, so
the directories which were +3, and +4 are now right behind the new head of
the list, while the two directories which were ahead of it get moved to the
end.  If the list before was:
verb(  dir1  dir2  dir3  dir4)
then after tt(pushd +2) you get
verb(  dir3  dir4  dir1 dir2)
That behaviour changed during the lifetime of zsh, and some of us preferred
the old behaviour, where that one directory was yanked to the front and the
rest just closed the gap:
verb(  # Old behaviour
  dir3  dir1  dir2  dir4)
so that after a while you get a `greatest hits' group at the front of the
list.  If you like this behaviour too (I feel as if I'd need to have written
papers on group theory to like the new behaviour) there is a function
tt(pushd) supplied with the source code, although it's short enough to
repeat here --- this is in the form for autoloading in the zsh fashion:
verb(  # pushd function to emulate the old zsh behaviour.
  # With this, pushd +/-n lifts the selected element
  # to the top of the stack instead of cycling
  # the stack.

  emulate -R zsh
  setopt localoptions

  if [[ ARGC -eq 1 && "$1" == [+-]<-> ]] then
          setopt pushdignoredups
          builtin pushd ~$1
  else
          builtin pushd "$@"
  fi)
The `tt(&&)' is a logical `and', requiring both tests to be true.  The
tests are that there is exactly one argument to the function, and that it
has the form of a `tt(+)' or a `tt(-)' followed by any number (`tt(<->)' is
a special zsh pattern to match any number, an extension of forms like
`tt(<1-100>)' which matches any number in the range 1 to 100 inclusive).

nsubsubsect(Referring to other directories)

Zsh has two ways of allowing you to refer to particular directories.  They
have in common that they begin with a tt(~) (in very old versions of zsh,
the second form actually used an `tt(=)', but the current way is much more
logical).

You will certainly be aware, because I've made a lot of use of it, that a
`tt(~)' on its own or followed by a tt(/) refers to your own home
directory.  An extension of this --- again from the C-shell, although the
Korn shell has it too in this case --- is that tt(~name) can refer to the
home directory of any user on the system.  So if your user name is tt(pws),
then tt(~) and tt(~pws) are the same directory.

Zsh has an extension to this; you can actually name your own directories.
This was described in lref(chapter)(init), à propos of prompts, since
that is the major use:
verb(  host% PS1='%~? '
  ~? cd zsh/Src
  ~/zsh/Src? zsrc=$PWD
  ~/zsh/Src? echo ~zsrc
  /home/pws/zsh/Src
  ~zsrc?)
Consult that chapter for the ways of forcing a parameter to be recognised
as a named directory.

There's a slightly more sophisticated way of doing this directly:
verb(  hash -d zsrc=~/zsh/Src)
makes tt(~zsrc) appear in prompts as before, and in this case there is no
parameter tt($zsrc).  This is the purist's way (although very few zsh users
are purists).  You can guess what `tt(unhash -d zsrc)' does; this works
with directories named via parameters, too, but leaves the parameter itself
alone.

It's possible to have a named directory with the same name as a user.  In
that case `tt(~name)' refers to the directory you named explicitly, and
there is no easy way of getting tt(name)'s home directory without removing
the name you defined.

If you're using named directories with one of the tt(cd)-like commands or
tt(AUTO_CD), you can set the option tt(CDABLEVARS) which allows you to
omit the leading tt(~); `tt(cd zsrc)' with this option would take you to
tt(~zsrc).  The name is a historical artifact and now a misnomer; it really
is named directories, not parameters (i.e. variables), which are used.

The second way of referring to directories with tt(~)'s is to use numbers
instead of names:  the numbers refer to directories in the directory
stack.  So if tt(dirs -v) gives you
verb(  0       ~zsf
  1       ~src)
then tt(~+1) and tt(~-0) (not very mathematical, but quite logical if you
think about it) refer to tt(~src).  In this case, unlike pushd
arguments, you can omit the tt(+) and use tt(~1).  The option
tt(PUSHD_MINUS) is respected.  You'll see this was used in the tt(pushd)
function above: the trick was that tt(~+3), for example, refers to the same
element as tt(pushd +3), hence tt(pushd ~+3) pushed that directory onto the
front of the list.  However, we set tt(PUSHD_IGNORE_DUPS), so that the
value in the old position was removed as well, giving us the effect we
wanted of simply yanking the directory to the front with no trick cycling.

subsect(Command control and information commands)

Various builtins exist which control how you access commands, and which
show you information about the commands which can be run.

The first two are strictly speaking `precommand modifiers' rather than
commands:  that means that they go before a command line and modify its
behaviour, rather than being commands in their own right.  If you put
`tt(command)' in front of a command line, the command word (the next one
along) will be taken as the name of an external command, however it would
normally be interpreted; likewise, if you put `tt(builtin)' in front, the
shell will try to run the command as a builtin command.  Normally, shell
functions take precedence over builtins which take precedence over external
commands.  So, for example, if your printer control system has the command
`tt(enable)' (as many System V versions do), which clashes with a builtin I
am about to talk about, you can run `tt(command enable lp)' to enable a
printer; otherwise, the builtin enable would have been run.  Likewise, if
you have defined tt(cd) to be a function, but this time want to call the
normal builtin tt(cd), you can say `tt(builtin cd mydir)'.

A common use for tt(command) is inside a shell function of the same name.
Sometimes you want to enhance an ordinary command by sticking some extra
stuff around it, then calling that command, so you write a shell function
of the same name.  To call the command itself inside the shell function,
you use `tt(command)'.  The following works, although it's obviously not
all that useful as it stands:
verb(  ls() {
    command ls "$[@]"
  })
so when you run `tt(ls)', it calls the function, which calls the real
tt(ls) command, passing on the arguments you gave it.

You can gain longer lasting control over the commands which the shell will
run with the `tt(disable)' and `tt(enable)' commands.  The first normally
takes builtin arguments; each such builtin will not be recognised by the
shell until you give an `tt(enable)' command for it.  So if you want to be
able to run the external tt(enable) command and don't particularly care
about the builtin version, `tt(disable enable)' (sorry if that's confusing)
will do the trick.  Ha, you're thinking, you can't run `tt(enable enable)'.
That's correct: some time in the dim and distant past, tt(builtin enable
enable)' would have worked, but currently it doesn't; this may change, if I
remember to change it.  You can list all disabled builtins with just
`tt(disable)' on its own --- most of the builtins that do this sort of
manipulation work like that.

You can manipulate other sets of commands with tt(disable) and tt(enable)
by giving different options: aliases with the option tt(-a), functions with
tt(-f), and reserved words with tt(-r).  The first two you probably know
about, and I'll come to them anyway, but `reserved words' need describing.
They are essentially builtin commands which have some special syntactic
meaning to the shell, including some symbols such as `tt({)' and `tt([[)'.
They take precedence over everything else except aliases --- in fact, since
they're syntactically special, the shell needs to know very early on that
it has found a reserved word, it's no use just waiting until it tries to
execute a command.  For example, if the shell finds `tt([[)' it needs to
know that everything until `tt(]])' must be treated as a test rather than
as ordinary command arguments.  Consequently, you wouldn't often want to
disable a reserved word, since the shell wouldn't work properly.  The most
obvious reason why you might would be for compatibility with some other
shell which didn't have one.  You can get a complete list with:
verb(  whence -wm '*' | grep reserved)
which I'll explain below, since I'm coming to `tt(whence)'.

Furthermore, I tend to find that if I want to get rid of aliases or
functions I use the commands `tt(unalias)' and `tt(unfunction)' to get rid
of them permanently, since I always have the original definitions stored
somewhere, so these two options may not be that useful either.  Disabling
builtins is definitely the most useful of the four possibilities for
tt(disable).

External commands have to be manipulated differently.  The types given
above are handled internally by the shell, so all it needs to do is
remember what code to call.  With external commands, the issue instead
is how to find them.  I mentioned tt(rehash) above, but didn't tell you
that the tt(hash) command, which  you've already
seen with the tt(-d) option, can be used to tell the shell how to find an
external command:
verb(  hash foo=/path/to/foo)
makes tt(foo) execute the command using the path shown (which doesn't even
have to end in `tt(foo)').  This is rather like an alias --- most people
would probably do this with an alias, in fact --- although a little faster,
though you're unlikely to notice the difference.  You can remove this with
tt(unhash).  One gotcha here is that if the path is rehashed, either by
calling tt(rehash) or when you alter tt($path), the entire hash table is
emptied, including anything you put in in this way; so it's not
particularly useful.

In the midst of all this, it's useful to be able to find out what the shell
thinks a particular command name does.  The command `tt(whence)' tells you
this; it also exists, with slightly different options, under the names
tt(where), tt(which) and tt(type), largely to provide compatibility with
other shells.  I'll just stick to tt(whence).

Its standard output isn't actually sparklingly interesting.  If it's a
command somehow known to the shell internally, it gets echoed back, with
the alias expanded if it was an alias; if it's an external command it's
printed with the full path, showing where it came from; and if it's not
known the command returns status 1 and prints nothing.

You can make it more useful with the tt(-v) or tt(-c) options, which are
more verbose; the first prints out an information message, while the second
prints out the definitions of any functions it was asked about (this is
also the effect of using `tt(which)' instead of `tt(whence)).  A very
useful option is tt(-m), which takes any arguments as patterns using the
usual zsh pattern format, in other words the same one used for matching
files.  Thus
verb(  whence -vm "*")
prints out every command the shell knows about, together with what it
thinks of it.

Note the quotes around the `tt(*)' --- you have to remember these anywhere
where the pattern is not to be used to generate filenames on the command
line, but instead needs to be passed to the command to be interpreted.  If
this seems a rather subtle distinction, think about what would happen if
you ran
verb(  # Oops.  Better not try this at home.
  # (Even better, don't do it at work either.)
  whence -vm *)
in a directory with the files `tt(foo)' and (guess what) `tt(bar)' in
it.  The shell hasn't decided what command it's going to run when it first
looks at the command line; it just sees the `tt(*)' and expands the line to
verb(  whence -vm foo bar)
which isn't what you meant.

There are a couple of other tricks worth mentioning:  tt(-p) makes
the shell search your path for them, even if the name is matched as
something else (say, a shell function).  So if you have tt(ls)
defined as a function,
verb(  which -p ls)
will still tell what `tt(command ls)' would find.  Also, the option
tt(-a) searches for all commands; in the same example, this would show you
both the tt(ls) command and the tt(ls) function, whereas tt(whence) would
normally only show the function because that's the one that would be run.
The tt(-a) option also shows if it finds more than one external command in
your path.

Finally, the option tt(-w) is useful because it identifies the type of a
command with a single word:  tt(alias), tt(builtin), tt(command),
tt(function), tt(hashed), tt(reserved) or tt(none).  Most of those are
obvious, with tt(command) being an ordinary external command; tt(hashed) is
an external command which has been explicitly given a path with the
tt(hash) builtin, and tt(none) means it wasn't recognised as a command at
all.  Now you know how we extracted the reserved words above.

A close relative of tt(whence) is tt(functions), which applies, of course,
to shell functions; it usually lists the definitions of all functions given
as arguments, but its relatives (of which tt(autoload) is one) perform
various other tricks, to be described in the section on shell functions
below.  Be careful with tt(function), without the `s', which is completely
different and not like tt(command) or tt(builtin) --- it is actually a
keyword used to em(define) a function.

subsect(Parameter control)

There are various builtins for controlling the shells parameters.
You already know how to set and use parameters, but it's a good deal more
complicated than that when you look at the details.

nsubsubsect(Local parameters)

The principal command for manipulating the behaviour of parameters is
`tt(typeset)'.  Its easiest usage is to declare a parameter; you just give
it a list of parameter names, which are created as scalar parameters.  You
can create parameters just by assigning to them, but the major point of
`tt(typeset)' is that if a parameter is created that way inside a function,
the parameter is restored to its original value, or removed if it didn't
previously exist, at the end of the function --- in other words, it has
`local scope' like the variables which you declare in most ordinary
programming languages.  In fact, to use the jargon it has `dynamical'
rather than `syntactic' scope, which means that the same parameter is
visible in any function called within the current one; this is different
from, say, C or FORTRAN where any function or subroutine called wouldn't
see any variable declared in the parent function.

The following makes this more concrete.
verb(  var='Original value'
  subfn() {
    print $var
  }
  fn() {
    print $var
    typeset var='Value in function'
    print $var
    subfn
  }
  fn
  print $var)
This chunk of code prints out
verb(  Original value
  Value in function
  Value in function
  Original value)
The first three chunks of the code just define the parameter tt($var), and
two functions, tt(subfn) and tt(fn).  Then we call tt(fn).  The first thing
this does is print out tt($var), which gives `tt(Original value)' since we
haven't changed the original definition.  However, the tt(typeset) next
does that; as you see, we can assign to the parameter during the typeset.
Thus when we print tt($var) out again, we get `tt(Value in function)'.
Then tt(subfn) is called, which prints out the same value as in tt(fn),
because we haven't changed it --- this is where C or FORTRAN would differ,
and wouldn't recognise the variable because it hadn't been declared in that
function.  Finally, tt(fn) exits and the original value is restored, and is
printed out by the final `tt(print)'.

Note the value changes twice: first at the tt(typeset), then again at the
end of tt(fn).  The value of tt($var) at any point will be one of those
two values.

Although you can do assignments in a tt(typeset) statement, you can't
assign to arrays (I already said this in the last chapter):
verb(  typeset var=(Doesn\'t work\!))
because the syntax with the parentheses is special; it only works when the
line consists of nothing but assignments.  However, the shell doesn't
complain if you try to assign an array to a scalar, or vice versa; it just
silently converts the type:
verb(  typeset var='scalar value'
  var=(array value))
I put in the assignment in the typeset statement to rub the point in that
it creates scalars, but actually the usual way of setting up an array in
a function is
verb(  typeset var
  var=())
which creates an empty scalar, then converts that to an empty array.
Recent versions of the shell have `tt(typeset -a var)' to do that in one go
--- but you em(still) can't assign to it in the same statement.

There are other catches associated with the fact that tt(typeset) and its
relatives are just ordinary commands with ordinary sets of arguments.
Consider this:
verb(  % typeset var=`echo two words`
  % print $var
  two)
What has happened to the `tt(words)'?  The answer is that backquote
substitution, to be discussed below, splits words when not quoted.  So the
tt(typeset) statement is equivalent to
verb(  % typeset var=two words)
There are two ways to get round this; first, use an ordinary assignment:
verb(  % typeset var
  % var=`echo two words`)
which can tell a scalar assignment, and hence knows not to split words, or
quote the backquotes,
verb(  % typeset var="`echo two words`")

There are three important types we haven't talked about; both of these can
only be created with tt(typeset) or one of the similar builtins I'll list
in a moment.  They are integer types, floating point types, and associative
array types.

nsubsubsect(Numeric parameters)

Integers are created with `tt(typeset -i)', or `tt(integer)' which is
another way of saying the same thing.  They are used for arithmetic, which
the shell can do as follows:
verb(  integer i
  (( i = 3 * 2 + 1 )))
The double parentheses surround a complete arithmetic expression:  it
behaves as if it's quoted.  The expression inside can be pretty much
anything you might be used to from arithmetic in other programming
languages.  One important point to note is that parameters don't need to
have the tt($) in front, even when their value is being taken:
verb(  integer i j=12
  (( i = 3 * ( j + 4 ) ** 2 )))
Here, tt(j) will be replaced by 12 and tt($i) gets the value 768 (sixteen
squared times three).  One thing you might not recognise is the tt(**),
which is the `to the power of' operator which occurs in FORTRAN and Perl.
Note that it's fine to have parentheses inside the double parentheses ---
indeed, you can even do
verb(  (( i = (3 * ( j + 4 )) ** 2 )))
and the shell won't get confused because it knows that any parentheses
inside must be in balanced pairs (until you deliberately confuse it with
your buggy code).

You would normally use `tt(print $i)' to see what value had been given to
tt($i), of course, and as you would expect it gets printed out as a decimal
number.  However, tt(typeset) allows you to specify another base for
printing out.  If you do
verb(  typeset -i 16 i
  print $i)
after the last calculation, you should see tt(16#900), which means 900 in
base 16 (hexadecimal).  That's the only effect the option `tt(-i 16)' has
on tt($i) --- you can assign to it and use it in arithmetical expressions
just as normal, but when you print it out it appears in this form.  You can
use this base notation for inputting numbers, too:
verb(  (( i = 16#ff * 2#10 )))
which means 255 (tt(ff) in hexadecimal) times 2 (tt(10) in binary).
The shell understands C notation too, so `tt(16#ff)' could have been
expressed `tt(0xff)'.

Floating point variables are very similar.  You can declare them with
`tt(typeset -F)' or `tt(typeset -E)'.  The only difference between the two
is, again, on output; tt(-F) uses a fixed point notation, while tt(-E) uses
scientific (mnemonic: exponential) notation.  The builtin `tt(float)' is
equivalent to `tt(typeset -E)' (because Korn shell does it, that's why).
Floating point expressions also work the way you are probably used to:
verb(  typeset -E e
  typeset -F f
  (( e = 32/3, f = 32.0/3.0 ))
  print $e $f)
prints
verb(  1.000000000e+01 10.6666666667)
Various points:  the `tt(,)' can separate different expressions, just like in
C, so the tt(e) and tt(f) assignments are performed separately.  The tt(e)
assignment was actually an integer division, because neither 32 nor 3 is a
floating point number, which must contain a dot.  That means an integer
division was done, producing 10, which was then converted to a floating
point number only at the end.  Again, this is just how grown-up languages
work, so it's no use cursing.  The tt(f) assignment was a full floating
point performance.  Floating point parameters weren't available before
version tt(3.1.7).

Although this is really a matter for a later chapter, there is a library of
floating point functions you can load (actually it's just a way of linking
in the system mathematical library).  The usual incantation is `tt(zmodload
zsh/mathfunc)'; you may not have `dynamic loading' of libraries on your
system, which may mean that doesn't work.  If it does, you can do things
like
verb(  (( pi = 4.0 * atan(1.0) )))
Broadly, all the functions which appear in most system mathematical
libraries (see the manual page for tt(math)) are available in zsh.

Like all other parameters created with tt(typeset) or one of its cousins,
integer and floating point parameters are local to functions.  You may
wonder how to create a global parameter (i.e. one which is valid outside as
well as inside the function) which has an integer or floating point value.
There's a recent addition to the shell (in version 3.1.6) which allows
this: use the flag tt(-g) to typeset along with any others.  For example,
verb(  fn() {
    typeset -Fg f
    (( f = 42.75 ))
  }
  fn
  print $f)
If you try it, you will see the value of tt($f) has survived beyond the
function.  The tt(g) stands for global, obviously, although it's not quite
that simple:
verb(  fn() {
    typeset -Fg f
  }
  outerfn() {
    typeset f='scalar value'
    fn
    print $f
  }
  outerfn)
The function tt(outerfn) creates a local scalar value for tt(f); that's
what tt(fn) sees.  So it was not really operating on a `global' value, it
just didn't create a new one for the scope of tt(fn).  The error message
comes because it tried to preserve the value of tt($f) while changing its
type, and the value wasn't a proper floating point expression.  The error
message,
verb(  fn: bad math expression: operator expected at `value')
comes about because assigning to numeric parameters always does an
arithmetic evaluation.  Operating on `tt(scalar value)' it found
`tt(scalar)' and assumed this was a parameter, then looked for an operator
like `tt(+)' to come next; instead it found `tt(value)'.  If you want to
experiment, change the string to `tt(scalar + value)' and set
`tt(value=42)', or whatever, then try again. This is a little confusing
(which is a roundabout way of saying it confused me), but consistent with
how zsh usually treats parameters.

Actually, to a certain extent you don't need to use the integer and
floating point parameters.  Any time zsh needs a numeric expression
it will force a scalar to the right value, and any time it produces a
numeric expression and assigns it to a scalar, it will convert the result
to a string.  So
verb(  typeset num=3            # This is the *string* `3'.
  (( num = num + 1 ))      # But this works anyway
                           # ($num is still a string).)
This can be useful if you have a parameter which is sometimes a number,
sometimes a string, since zsh does all the conversion work for you.
However, it can also be confusing if you always want a number, because zsh
can't guess that for you; plus it's a little more efficient not to have to
convert back and forth; plus you lose accuracy when you do, because if the
number is stored as a string rather than in the internal numeric
representation, what you say is what you get (although zsh tends to give
you quite a lot of decimal places when converting implicitly to strings).
Anyway, I'd recommend that if you know a parameter has to be an integer or
floating point value you should declare it as such.

There is a builtin called tt(let) to handle mathematical expressions, but
since
verb(  let "num = num + 1")
is equivalent to
verb(  (( num = num + 1 )))
and the second form is easier and more memorable, you probably won't need
to use it.  If you do, remember that (unlike BASIC) each mathematical
expression should appear as one argument in quotes.

nsubsubsect(Associative arrays)

The one remaining major type of parameter is the associative array; if
you use Perl, you may call it a `hash', but we tend not to since that's
really a description of how it's implemented rather than what it does.
(All right, what it does is hash things.  Now shut up.)

These have to be declared by a typeset statement --- there's no getting
round it.  There are some quite eclectic builtins that
produce a filled-in associative array for you, but the only way to tell zsh
you want your very own associative array is
verb(  typeset -A assoc)
to create tt($assoc).  As to what it does, that's best shown by example:
verb(  typeset -A assoc
  assoc=(one eins two zwei three drei)
  print ${assoc[two]})
which prints `tt(zwei)'.  So it works a bit like an ordinary array, but the
numeric em(subscript) of an ordinary array which would have appeared inside
the square bracket is replaced by the string em(key), in this case tt(two).
The array assignment was a bit deceptive; the `values' were actually
pairs, with `tt(one)' being the key for the value `tt(eins)', and so on.  The
shell will complain if there are an odd number of elements in such a list.
This may also be familiar from Perl.  You can assign values one at a time:
verb(  assoc[four]=vier)
and also unset one key/value pair:
verb(  unset 'assoc[one]')
where the quotes stop the square brackets from being interpreted as a pattern
on the command line.

Expansion has been held over, but you might like to know about the ways of
getting back what you put in.  If you do
verb(  print $assoc)
you just see the values --- that's exactly the same as with an ordinary
array, where the subscripts 1, 2, 3, etc. aren't shown.  Note they are in
random order --- that's the other main difference from ordinary arrays;
associative arrays have no notion of an order unless you explicitly sort
them.

But here the keys may be just as interesting.  So there is:
verb(  print ${(k)assoc}
  print ${(kv)assoc})
giving (if you've followed through all the commands above):
verb(  four two three
  four vier two zwei three drei)
which print out the keys instead of the values, and the key and value pairs
much as you entered them.  You can see that, although the order of the
pairs isn't obvious, it's the same each time.  From this example you can
work out how to copy an associative array into another one:
verb(  typeset -A newass
  newass=(${(kv)assoc}))
where the `tt((kv))' is important --- as is the tt(typeset) just before the
assignment, otherwise tt($newass) would be a badass ordinary array.  You
can also prove that tt(${(v)assoc}) does what you would probably expect.
There are lots of other tricks, but they are mostly associated with clever
types of parameter expansion, to be described in lref(chapter)(subst).

nsubsubsect(Other typeset and type tricks)

There are variants of tt(typeset), some mentioned sporadically above.
There is nothing you can do with any of them that you can't do with
tt(typeset) --- that wasn't always the case; we've tried to improve the
orthogonality of the options.  They differ in the options which are set by
default, and the additional options which are allowed.  Here's a list:
tt(declare), tt(export), tt(float), tt(integer), tt(local), tt(readonly).
I won't confuse you by describing all in detail; see the manual.

If there is an odd one out, it's tt(export), which not only marks a
parameter for export but has the tt(-g) flag turned on by default, so that
that parameter is not local to the function; in other words, it's
equivalent to tt(typeset -gx).  However, one holdover from the days when
the options weren't quite so logical is that tt(typeset -x) behaves like
tt(export), in other words the tt(-g) flag is turned on by default.  You
can fix this by unsetting the option tt(GLOBAL_EXPORT) --- the option only
exists for compatibility; logically it should always be unset.  This is
partly because in the old days you couldn't export local parameters, so
tt(typeset -x) either had to turn on tt(-g) or turn off tt(-x); that was
fixed for the 3.1.9 release, and (for example) `tt(local -x)' creates a
local parameter which is exported to the environment; both the parameter
itself, and the value in the environment, will be restored when the
function exits.  The builtin tt(local) is essentially a form of tt(typeset)
which renounces the tt(-g) flag and all its works.

Another old restriction which has gone is that you couldn't make special
parameters, in particular tt($PATH), local to a function; you just modified
the original parameter.  Now if you say `tt(typeset PATH)', things happen
the way you probably expect, with tt($PATH) having its usual effect, and
being restored to its old value when the function exits.  Since tt($PATH)
is still special, though, you should make sure you assign something to it
in the function before calling external commands, else it will be empty and
no commands will be found.  It's possible that you specifically don't want
some parameter you make local to have the special property; 3.1.7 and after
allow the typeset flag tt(-h) to hide the specialness for that parameter,
so in `tt(typeset -h PATH)', tt(PATH) would be an ordinary variable for the
duration of the enclosing function.  Internally, the same value as was
previously set would continue to be used for finding commands, but it
wouldn't be exported.

The second main use of tt(typeset) is to set attributes for the parameters.
In this case it can operate on an existing parameter, as well as creating a
new one.  For example,
verb(  typeset -r msg='This is an important message.')
sets the readonly flag (-r) for the parameter tt(msg).  If the parameter
didn't exist, it would be created with the usual scoping rules; but if it
did exist at the current level of scoping, it would be made readonly with
the value assigned to it, meaning you can't set that particular copy of
the parameter.  For obvious reasons, it's normal to assign a value to a
readonly parameter when you first declare it.  Here's a reality check on
how this affects scoping:
verb(   msg='This is an ordinary parameter'
   fn() {
     typeset msg='This is a local ordinary parameter'
     print $msg
     typeset -r msg='This is a local readonly parameter'
     print $msg
     msg='Watch me cause an error.'
   }
   fn
   print $msg
   msg='This version of the parameter'\ 
   ' can still be overwritten'
   print $msg)
outputs
verb(  This is a local ordinary parameter
  This is a local readonly parameter
  fn:5: read-only variable: msg
  This is an ordinary parameter
  This version of the parameter can still be overwritten)
Unfortunately there was a bug with this code until recently --- thirty
seconds ago, actually:  the second tt(typeset) in tt(fn) incorrectly added
the readonly flag to the existing tt(msg) em(before) attempting to set the
new value, which was wrong and inconsistent with what happens if you create
a new local parameter.  Maybe it's reassuring that the shell can get
confused about local parameters, too.  (I don't find it reassuring in the
slightest, since tt(typeset) is one of the parts of the code where I tend
to fix the bugs, but maybe you do.)

Anyway, when the bug is fixed, you should get the output shown, because the
first typeset created a local variable which the second typeset made
readonly, so that the final assignment caused an error.  Then the tt($msg)
in the function went out of scope, and the ordinary parameter, with no
readonly restriction, was visible again.

I mentioned another special typeset option in the previous chapter:
verb(  typeset -T TEXINPUTS texinputs)
to tie together the scalar tt($TEXINPUTS) and the array tt($texinputs) in
the same way that tt($PATH) and tt($path) work.  This is a one-off; it's
the only time tt(typeset) takes exactly two parameter names on the command
line.  All other uses of typeset take a list of parameters to which any
flags given are applied.  See the manual for the remaining flags, although
most of the more interesting ones have been discussed.

The other thing you need to know about flags is that you use them with a
`tt(CHAR(43))' sign to turn off the corresponding attribute.  So
verb(  typeset +r msg)
allows you to set tt($msg) again.  From version tt(4.1), you won't be able
to turn off the readonly attribute for a special parameter; that's because
there's too much scope for confusion, including attempting to set constant
strings in the code.  For example, `tt($ZSH_VERSION)' always prints a fixed
string; attempting to change that is futile.

The final use of typeset is to list parameters.  If you type `tt(typeset)'
on its own, you get a complete list of parameters and their values.  From
3.1.7, you can turn on the flag tt(-H) for a parameter, which means to hide
its value while you're doing this.  This can be useful for some of the more
enormous parameters, particularly special parameters which I'll talk about
in the section in lref(chapter)(ragbag) on modules, which tend to swamp
the display tt(typeset) produces.

You can also list parameters of a particular type, by listing the flags you
want to know about.  For example,
verb(  typeset -r)
lists all readonly parameters.  You might expect `tt(typeset +r)' to list
parameters which em(don't) have that attribute, but actually it lists the
same parameters but without showing their value.  `tt(typeset +)' lists all
parameters in this way.

Another good way of finding out about parameters is to use the special
expansion `tt(${(t))var(param)tt(})', for example
verb(  print ${(t)PATH})
prints `tt(scalar-export-special)':  tt($PATH) is a scalar parameter, with
the tt(-x) flag set, and has a special meaning to the shell.  Actually,
`tt(special)' means something a bit more than that:  it means the internal
code to get and set the parameter behaves in a way which has side effects,
either to the parameter itself or elsewhere in the shell.  There are
other parameters, like tt($HISTFILE), which are used by the shell, but
which are get and set in a normal way --- they are only special in that the
value is looked at by the shell; and, after all, any old shell function can
do that, too.  Contrast this with tt($PATH) which has all that
paraphernalia to do with hashing commands to take care of when it's set,
as I discussed above, and I hope you'll see the difference.

nsubsubsect(Reading into parameters)

The `tt(read)' builtin, as its name suggests, is the opposite to
`tt(print)' (there's no `tt(write)' command in the shell, though there is
often an external command of that name to send a message to another user),
but reading, unlike printing, requires something in the shell to change to
take the value, so unlike tt(print), tt(read) is forced to be a builtin.
Inevitably, the values are read into a parameter.  Normally they are taken
from standard input, very often the terminal (even if you're running a
script, unless you redirected the input).  So the simplest case is just
verb(  read param)
and if you type a line, and hit return, it will be put into tt($param),
without the final newline.

The tt(read) builtin actually does a bit of processing on the input.  It
will usually strip any initial or final whitespace (spaces or tabs) from
the line read in, though any in the middle are kept.  You can read a set of
values separated by whitespace just by listing the parameters to assign
them to; the last parameter gets all the remainder of the line without it
being split.  Very often it's easiest just to read into an array:
verb(  % read -A array
        this is a line typed in now, \ 
      by me,    in this   space
  % print ${array[1]} ${array[12]}
  this space)
(I'm assuming you're using the native zsh array format, rather than the one
set with tt(KSH_ARRAYS), and shall continue to assume this.)

It's useful to be able to print a prompt when you want to read something.
You can do this with `tt(print -n)', but there's a shorthand:
verb(  % read line'?Please enter a line: '
  Please enter a line: some words
  % print $line
  some words)
Note the quotes surround the `tt(?)' to prevent it being taken as part of a
pattern on the command line.  You can quote the whole expression from the
beginning of `tt(line)', if you like; I just write it like that because I
know parameter names don't need quoting, because they can't have funny
characters in.  It's almost logical.

Another useful trick with tt(read) is to read a single character; the
`tt(-k)' option does this, and in fact you can stick a number immediately
after the `tt(k)' which specifies a number to read.  Even easier, the
`tt(-q)' option reads a single character and returns status 0 if it was
tt(y) or tt(Y), and status 1 otherwise; thus you can read the answer to
yes/no questions without using a parameter at all.  Note, however, that if
you don't supply a parameter, the reply gets assigned in any case to
tt($REPLY) if it's a scalar --- as it is with tt(-q) --- or tt($reply) if
it's an array --- i.e. if you specify tt(-A), but no parameter name.  These
are more examples of the non-special parameters which the shell uses --- it
sets tt($REPLY) or tt($reply), but only in the same way you would set
them; there are no side-effects.

Like tt(print), tt(read) has a tt(-r) flag for raw mode.  However, this
just has one effect for tt(read):  without it, a tt(\) at the end of the
line specifies that the next line is a continuation of the current one (you
can do this when you're typing at the terminal).  With it, tt(\) is not
treated specially.

Finally, a more sophisticated note about word-splitting.  I said that, when
you are reading to many parameters or an array, the word is split on
whitespace.  In fact the shell splits words on any of the characters found
in the (genuinely special, because it affects the shell's guts) parameter
tt($IFS), which stands for `input field separator'.  By default --- and in
the vast majority of uses --- it contains space, tab, newline and a null
character (character zero:  if you know that these are usually used to mark
the end of strings, you might be surprised the shell handles these as
ordinary characters, but it does, although printing them out usually
doesn't show anything).  However, you can set it to any string: enter
verb(  fn() {
    local IFS=:
    read -A array
    print -l $array
  }
  fn)
and type
verb(one word:two words:three words:four)
The shell will show you what's in the array it's read, one `word' per
line:
verb(  one word
  two words
  three words
  four)
You'll see the bananas, er, words (joke for the over-thirties) have been
treated as separated by a colon, not by whitespace.  Making tt($IFS) local
didn't work in old versions of zsh, as with other specials; you had to save
it and restore it.

The tt(read) command in zsh doesn't let you do line editing, which some
shells do.  For that, you should use the tt(vared) command, which runs the
line editor to edit a parameter, with the tt(-c) option, which allows
tt(vared) to create a new parameter.  It also takes the option tt(-p) to
specify a prompt, so one of the examples above can be rewritten
verb(  vared -c -p 'Please enter a line: ' line)
which works rather like read but with full editing support.  If you give
the option tt(-h) (history), you can even retrieve values from previous
command lines.  It doesn't have all the formatting options of read,
however, although when reading an array (use the option tt(-a) with tt(-c)
if creating a new array) it will perform splitting.

nsubsubsect(Other builtins to control parameters)

The remaining builtins which handle parameters can be dealt with more
swiftly.

The builtin tt(set) simply sets the special parameter which is passed as an
argument to functions or scripts, and which you access as tt($*) or tt($@),
or tt($<number>) (Bourne-like format), or via tt($argv) (csh-like format),
known however you set them as the `positional parameters':
verb(  % set a whole load of words
  % print $1
  a
  % print $*
  a whole load of words
  % print $argv[2,-2]
  whole load of)
It's exactly as if you were in a function and had called the function with
the arguments `tt(a whole load of words)'.  Actually, set can also be used
to set shell options, either as flags, e.g. `tt(set -x)', or as words after
`tt(-o)' , e.g. `tt(set -o xtrace)' does the same as the previous example.
It's generally easier to use tt(setopt), and the upshot is that you need to
be careful when setting arguments this way in case they begin with a
`tt(-)'.  Putting `tt(-)tt(-)' before the real arguments fixes this.

One other use of tt(set) is to set any array, via
verb(  set -A any_array words to assign to any_array)
which is equivalent to (and the standard Korn shell version of)
verb(  any_array=(words to assign to any_array))
One case where the tt(set) version is more useful is if the name of an
array itself comes from a parameter:
verb(  arrname=myarray
  set -A $arrname words to assign)
has no easy equivalent in the other form; the left hand side of an
ordinary assignment won't expand a parameter:
verb(  # Doesn't work; syntax error
  $arrname=(words to assign))
This worked in old versions of zsh, but that was on the non-standard side.
The tt(eval) command, described below, gives another way around this.

Next comes `tt(shift)', which simply moves an array up one element,
deleting the original first one.  Without an array name, it operates on the
positional parameters.  You can also give it a number to shift other than
one, before the array name.
verb(  shift array)
is equivalent to
verb(  array=(${array[2,-1]}))
(almost --- I'll leave the subtleties here for the chapter on expansion)
which picks the second to last elements of the array and assigns them back
to the original array.  Note, yet again, that tt(shift) operates using the
em(name), not the em(value) of the array, so no `tt($)' should appear in
front, otherwise you get something similar to the trick I showed for `tt(set
-A)'.

Finally, tt(unset) unsets a parameter, and I already showed you could unset
a key/value pair of an associative array.  There is one subtlety to be
mentioned here.  Normally, tt(unset) just makes the parameter named
disappear off the face of the earth.  However, if you call tt(unset) in a
function, its ghost lives on in the sense that any parameter you create in
the same name will be scoped as the original parameter was.  Hence:
verb(  var='global value'
  fn() {
    typeset var='local value'
    unset var
    var='what about this?'
  }
  fn
  print $var)
The final statement prints `tt(global value)':  even though the local
copy of tt($var) was unset, the shell remembers that it was local, so
the second tt($var) in the function is also local and its value
disappears at the end of the function.

subsect(History control commands)

The easiest way to access the shell's command history is by editing it
directly.  The second easiest way is to use the `tt(!)'-history
mechanism.  Other ways of manipulating it are based around the tt(fc)
builtin, which probably once stood for something (according to Oliver
Kiddle, `fix command', which is as good as anything).  I talked quite a
bit about it in the last chapter, and don't really have anything to add.
Just note that the two other commands based around it are tt(history)
and tt(r).

subsect(Job control and process control)

One of the major contributions of the C-shell was job control.  You need
to know about foreground and background tasks, and again I introduced
these in the last chapter along with the options that control them.
Here is an introduction to the relevant builtins.

You start a background job in two ways.  First, directly, by putting an
`tt(&)' after it:
verb(  sleep 10 &)
and secondly by starting it in the normal way (i.e. in the foreground),
then typing tt(^Z), and using the tt(bg) command to put it in the
background.  Between typing tt(^Z) and tt(bg), the job is still there, but
is not running; it is `suspended' or `stopped' (systems use different
descriptions for the same thing), waiting for you to decide what to do
with it.  In either case, the job then continues without the shell waiting
for it.  It will still try and read from or write to the terminal if
that's how you started it; you need to use the shell's redirection
facilities right at the start if you want to change that, there's
nothing you can do after the job has already started.

By the way, `sleep' isn't a builtin.  Oddly enough, you can suspend a
builtin command or sequence of commands (such as shell function) with
tt(^Z), although since the shell has to continue executing your commands
as well as being suspended, it does the only thing it can do --- fork, so
that the commands you suspend are put into the background.  Probably
you will only rarely do this with builtins.  No other shell, so far as I
know, has this feature.

A job will stop if it needs to read from the terminal.  You see a
message like:
verb(  [1]  + 1348 suspended (tty input)  jobname and arguments)
which means the job is suspended very much like you had just typed
tt(^Z).  You need to bring the job into the forground, as described
below, so that you can type something to it.

By the way, the key to type to suspend a command may not be tt(^Z); it
usually is, but that can be changed.  Run `tt(stty -a)' and look for what
is listed after `tt(susp =)' --- probably, but not necessarily, tt(^Z).  So
if you want to use another character --- it must be a single character;
this is handled deep in the terminal interface, not in the shell --- you
can run
verb(  stty susp '^]')
or whatever.  You will note from the tt(stty) output that various other job
control characters can be changed similarly.  The tt(stty) command is
external and its format for both output and input can vary quite a bit
from system to system.

Instead of putting the command into the background, you can bring it back
to the foreground again with tt(fg).  This is useful for temporarily
stopping what you are doing so you can do something else.  These days you
would probably do it in another window; in the old days when people
logged in from simple terminals this was even more useful.  A typical
example of this is
verb(  more file                        # look at file
  ^Z                               # suspend
  [1] + 8592 suspended  more file  # message printed
  ...                              # do something else
  fg %1                            # resume the `more')
The `tt(%)' is the usual way of referring to jobs.  The number after it is
what appeared in square brackets with the suspended message; I don't know
why the shell doesn't use the `tt(%)' notation there, too.  You also see
that with the `continued' message when you put something into the
background, and again at the end with the `done' message which tells you
a background job is finished.  The `tt(%)' can take other forms; the most
common is to follow it by the name of a command, such as `tt(%more)' in
this case.  The forms tt(%+) and tt(%-) refer to the most recent and second
most recent jobs --- the `tt(+)' in the `suspended' message is telling you
that the tt(more) job could be referred to like that.

Most of the job control commands will actually assume you are talking
about `tt(%+)' if you don't give an argument, so assuming I hadn't
started any other commands in the background, I could just have put
`tt(fg)' at the end of the sequence of commands above.  This actually
cuts both ways: tt(fg) is the default operation on jobs referred to with
the `tt(%)' notation, so just typing `tt(%1)' with no command name would
have worked, too.

You can jog your memory about what's going on with the `tt(jobs)'
command.  It looks like a series of messages of the form beginning with the
number in square brackets; usually the jobs will either be `running' or
`suspended'.  This will tell you the numbers you need.

One other useful thing you can do with a job is to tell the shell to forget
about it.  This is only really useful if it is already running in the
background; then you can run `tt(disown)' with the job identifier.  It's
useful for jobs you want to continue after you've logged out, as well as
jobs that have their own windows which you can therefore control directly.
With disowned jobs, the shell doesn't warn you that they are still there
when you log out.  You can actually disown a background job when you start
it by putting `tt(&|)' or `tt(&!)' at the end of the line instead of simply
`tt(&)'.  Note that if the job was suspended when you disowned it, it
will stay disowned; this is pretty pointless, so you probably should run
`tt(bg)' on it first.

The next most likely thing you want to do with a job is kill it, or maybe
suspend it when it's already in the background and you can't just type
tt(^Z).  This is where the tt(kill) builtin comes in.  There's more
to this than there is to the builtins mentioned above.  First, you can use
tt(kill) with other processes that weren't started from the current shell.
In that case, you would use a number to identify it, with no tt(%) ---
that's why the tt(%)'s were there in the other cases.  Of course, you need
to find out the number; the usual way is with the tt(ps) command, which is
not a builtin but which appears on all UNIX-like systems.  As a stupid
example, here I start a disowned process which does very little, look for
it, then kill it:
verb(  % sleep 60 &|
  % ps -f
  UID        PID  PPID  C STIME TTY          TIME CMD
  pws        623   614  0 22:12 pts/0    00:00:00 zsh
  pws       8613   623  0 23:12 pts/0    00:00:00 sleep 60
  pws       8615   623  0 23:12 pts/0    00:00:00 ps -f
  % kill 8613
  % ps -f
  UID        PID  PPID  C STIME TTY          TIME CMD
  pws        623   614  0 22:12 pts/0    00:00:00 zsh
  pws       8616   623  0 23:12 pts/0    00:00:00 ps -f)
The process has disappeared the second time I look.  Notice that in the
usual lugubrious UNIX way the shell didn't bother to tell you the process
had been killed; however, it will report an error if it failed to
send it the signal.  Sending it the signal is all the shell cares about;
the shell won't warn if you if the process decided it didn't want to die
when told to, so it's still a good idea to check.

Sometimes you want to wait for a process to exit; the tt(wait) builtin can
do this, and like tt(kill) can take a process number as well as a job
number.  However, that's a bit deceptive --- you can't actually wait for a
process which wasn't started directly from the shell.  Indeed, the
mechanism for waiting is all bound up with the way UNIX handles processes;
unless its parent waits for it, a process becomes a `zombie' and hangs
around until the system's foster parent, the `init' process (always process
number 1) waits for it instead.  It's all a little bit baroque, but for the
shell user, wait just means you can hang on until something you started has
finished.  Indeed, that's how foreground processes work: the shell in
effect uses the internal version of tt(wait) to hang around until the job
exits.  (Well, actually that's a lie; the system wakes it up from whatever
it's doing to tell it a child has finished, so all it has to do is doze off
to wait.)

Furthermore, you can wait for a process even if job control isn't running.
Job control, basically anything involving those tt(%)'s, is only useful
when you are sitting at a terminal fiddling with commands; it doesn't
operate when you run scripts, say.  Then the shell has much less freedom in
how to control its jobs, but it can still wait for a background process,
and it can still use tt(kill) on a process if it knows its number.  For
this purpose, the shell stores the ID of the last process started in the
background in the parameter tt($!); there's probably a good reason for
the `tt(!)', but I don't know what it is.  This happens regardless of job
control.

nsubsubsect(Signals)

The tt(kill) command can do a good deal more than just kill a process.
That is the default action, which is why the command has that name.  But
what it's really doing is sending a `signal' to a process.  Signals are
the simplest way of communicating to another process; in fact, they are
about the only simple way if you haven't made special arrangements for
the process to read messages from you.  Signal names are written like
tt(SIGINT), tt(SIGTSTP), tt(SIGKILL); to send a particular signal to a
process, you remove the tt(SIG), stick a hyphen in front, and use that
as the first argument to tt(kill), e.g.:
verb(  kill -KILL 8613)
Some of the things you already know about are actually doing just that.
When you type tt(^C) to stop a process, you are actually sending it a
tt(SIGINT) for `interrupt', as if you had done
verb(  kill -INT 8613)
The usual signal sent by tt(kill) is not, as you might have guessed,
tt(SIGKILL), but actually tt(SIGTERM) for `terminate'; tt(SIGKILL) is
stronger as the process can't block that signal, as it can with many (we'll
see how the shell can do that in a moment).  It's familiar to UNIX hackers
as `tt(kill -9)', because all the signals also have numbers.  You can see
the list of signals in zsh by doing:
verb(  % print $signals
  EXIT HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1
  SEGV USR2 PIPE ALRM TERM STKFLT CLD CONT STOP TSTP
  TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR
  UNUSED ZERR DEBUG)
Your list will probably be different from mine; this is for Linux, and the
list is very system-specific, even though the first nine are generally the
same, and many of the others are virtually always present.  Actually,
tt(SIGEXIT) is an invention by the shell for you to allow the shell to do
something when a function exits (see the section on `traps' below); you
can't actually use `tt(kill -EXIT)'.  Thus tt(SIGHUP) is the first real
signal, and indeed that's number one, so you have to shift the contents
of tt($signals) along one to get the right numbers.  tt(SIGTERM) and
tt(SIGINT) usually have the same effect, stopping the process, unless
that has decided to handle the signal some other way.

The last two signals are bogus, too:  tt(SIGZERR) is to allow the shell
to do something on an error (non-zero exit status), while with
tt(SIGDEBUG) you can do it on every command.  Again, the `something' to
be executed is a `trap', as I'll discuss in a short while.

Typing tt(^Z) to suspend a process actually sends the process a tt(SIGTSTP)
(terminal stop, since it usually comes from the terminal), while
tt(SIGSTOP) is similar but usually doesn't come from a terminal.  Even
restarting a process as with tt(bg) sends it a signal, in this case
tt(SIGCONT).  It seems a bit odd to signal a process to restart; why can't
the operating system just restart it when you ask?  The real answer is
probably that signals provide an easy way for you to talk to the operating
system without grovelling around in the dirt too much.

Before I talk about how you make the shell handle signals it receives,
there is one extra oddment: the tt(suspend) builtin effectively sends the
shell a signal to suspend it, as if you'd typed tt(^Z), though as you've
probably found by now that doesn't suspend the shell itself.  It's only
useful to do this if the shell is running under some other programme, else
there's no way of restoring it and suspending is effectively the same as
exiting the shell.  For this reason, the shell won't let you call
tt(suspend) in a login shell, because it assumes that is running as the top
level (though in the previous chapter you learnt there's actually nothing
that special about login shells; you can start one just with `zsh -l').
If you're logged in remotely via tt(rsh) or tt(ssh), it's usually more
convenient to use the keystrokes `tt(~^Z)' which those define, rather than
zsh's mechanism; they have to be at the beginning of a line, so hit return
first if necessary.  This returns you to your local terminal; you can
resume the remote login with `tt(fg)' just like any other programme.

nsubsubsect(Traps)

The way of making the shell handle signals is called `traps'.  There are
actually two mechanisms for this.  I'll present the more standard one and
then talk about the advantages and drawbacks of the other one at the end.

The standard version (shared with other shells) is via the `tt(trap)'
builtin.  The first argument is a chunk of shell code to execute, which
obviously needs to be quoted when you pass it as an argument, and the
remaining arguments are a list of signals to handle, minus the tt(SIG)
prefix.  So:
verb(  trap "echo I\\'m trapped." INT)
tells the shell what to do on tt(SIGINT), i.e. tt(^C).  Note the extra
layer of quoting:  the double quotes surround the code, so that when they
are stripped tt(trap) sees the chunk
verb(  echo I\'m trapped)
Usually the shell would abort what it was doing and return to the main
prompt when you hit tt(^C).  Now, however, it will simply print the message
and carry on.  You can try this, for example, with
verb(  read line)
If you hit tt(^C) while it's waiting for input, you'll see the message go
up, but the shell will still wait for you to type a line.

A warning about this:  tt(^C) is only trapped within the shell itself.  If
you start up an external programme, it will have its own mechanism for
handling signals, and if it usually aborts on tt(^C) it still will.  But
there's a sting in the tail: do
verb(  cat)
which waits for input to output again (you need to use tt(^D) to exit
normally).  If you type tt(^C) here, the command will be aborted, as I said
--- but you still get the message `tt(I'm trapped)'.  That's because the
shell is able to tell that the command got that particular signal, and
calls the trap when the tt(cat) exits.  Not all shells do this;
furthermore, some commands which handle signals themselves won't give the
shell enough information to know that a signal arrived, and in that case
the trap won't be called.  Such commands are usually the more sophisticated
things like editors or screen managers or whatever; you just have to find
out by trial and error.

You can also make the shell ignore the signal completely.  To do this, the
first argument should be an empty string:
verb(  trap '' INT)
Now tt(^C) will have no effect, and em(this) time the effect em(is) passed
on directly to commands called from the shell --- try the tt(cat) example
and you won't be able to interrupt it; type tt(^D) or use the lesser known
but more powerful tt(^\) (control with backslash), which sends
tt(SIGQUIT).  If it hasn't been disabled, this will also produce a file
tt(core), which contains debugging information about what the programme was
doing when it exited --- never call your own files tt(core).  You can trap
tt(SIGQUIT) too, if you want.  (The shell itself usually ignores
tt(SIGQUIT); it's only useful for external commands.)

Now the other sort of trap.  I could have written for the first example:
verb(  TRAPINT() {
    print I\'m trapped.
  })
As you can see, this is just a function:  functions beginning tt(TRAP) are
special.  However, it's a real function too; you can call it by hand with
the command `TRAPINT', and it will run perfectly happily with no funny side
effects.

There is a difference between the way the two types work.  In the
`tt(trap)' sort of trap, the code is just evaluated just as if it appeared
as instructions to the shell at the point where the trap happened.  So if
you were in a function, you would see the environment of that function with
its local variables; if you set a local variable with tt(typeset), it would
be visible in the function just as if it were created there.

However, in the function type of trap, the code is provided with its own
function environment.  Now if you use tt(typeset) the parameter created is
local only to the trap.  In most cases, that's all the difference there is;
it's up to you to decide which is more convenient.  As you can see, the
function type of trap doesn't require the extra layer of quoting, so looks
a little smarter.  Conveniently, the `tt(trap)' command on its own lists
all traps in the form of the shell code you'd need to recreate them, and you
can see which sort is which.

There are two cases where the difference sticks out.  One is that the
function type has some extra wiring to allow you both to trap a signal,
and pretend to anyone watching that the shell didn't handle it.  An example
will show this:
verb(  TRAPINT() {
    print "Signal caught, stopping anyway."
    return $(( 128 + $1 ))
  })
That second line may look as rococo as the Amalienburg, but it's meaning is
this: tt($1), the first argument to the function, is set to the number of
the signal.  In this case it will be 2 because that's the standard number
for tt(SIGINT).  That means the arithmetic substitution tt($((...)))
returns 130, the command `tt(return 130)' is executed, and the function
returns with status 130.  Returning with non-zero status is special in
function traps:  it tells the shell you want to abort the surrounding
command even though the trap was handled, and that you want the status
associated with that to be 130.  It so happens that this is how UNIX handles
returns from normal traps.  Without setting a trap, do
verb(  % cat
  ^C
  % print $?)
and you'll see that this, too, has given the status 130, 128 plus the value
of tt(SIGINT).  So if you em(do) have the trap set, you'll see the message,
but the command will abort --- even if it was running inside the shell.

Try
verb(  % read line
  ^C)
to see that happening.  If you look at the status in tt($?) you'll find
it's actually 1, not 130; that's because the tt(read) command, when it
aborted, overrode the return value from the trap.  But it does that with an
untrapped tt(^C), too, so that's not really an exception to what I've just
said.

If you've been paying attention, you'll realise that traps set with the
tt(trap) builtin can't do it in quite this way, because the function they
return from would be whatever function you were in.  You can see that:
verb(  trap 'echo Returning...; return;' INT
  fn() {
    print In fn...
    read param
    print Leaving fn..
  })
If you run tt(fn) and hit tt(^C), the signal is trapped and the message
printed, but because of the tt(return), the shell quits tt(fn) immediately
and you don't see the final message.  If you missed out the `tt(return;)'
(try it), the shell would carry on with the rest of tt(fn) after you typed
something to tt(read).  Of course you can use this mechanism to leave
functions after trapping a signal; it just so happens that in this case the
mechanism with tt(TRAPINT) is a little closer to what untrapped signals do
and hence a little neater.

One final flourish of late Baroque splendour:  the trap for tt(SIGEXIT), the
one called when a function (or the shell itself, in fact) exits is a bit
special because in the case of exiting a function it will be called in the
environment of the calling function.  So if you need to do something like
set a local variable for an enclosing function you can have
verb(  trap 'typeset param_in_enclosing_func=value' EXIT)
do it for you; you couldn't do that with tt(TRAPEXIT) because the code
would have its own function, so that even though it would be called after
the first function exited, it wouldn't run directly in the enclosing one
but in a separate tt(TRAPEXIT) function.  You can even set an EXIT trap
for the enclosing function by defining a nested `tt(trap .. EXIT)'
inside that trap itself.

I lied, because there is one more special thing about tt(TRAPEXIT): it's
always reset after you exit a function and the trap itself has been called.
Most traps just hang around until you explicitly unset them.  There is an
option, tt(LOCAL_TRAPS), which makes traps set inside functions as well
insulated as possible from those outside, or inside deeper functions.  In
other words, the old trap is saved and then restored when you exit the
function; the scoping works pretty much like that for tt(typeset), and in
the same way traps for the enclosing scope, apart from any for tt(EXIT),
remain in effect inside a function unless you explicitly override them;
and, again in the same way, if you unset it inside the function it will
still be restored on exit.

tt(LOCAL_TRAPS) is the fixed behaviour of some other shells.  In zsh,
without the option set:
verb(  trap 'echo Hi.' INT
  fn() {
     trap 'echo Bye.' INT
  })
Calling tt(fn) simply replaces the trap defined outside the function with
the one defined inside while:
verb(  trap 'echo Hi.' INT
  fn() {
     setopt localtraps
     trap 'echo Bye.' INT
  })
puts the original `Hi' trap back after the function exits.

I haven't told you how to unset a trap for good:  the answer is
verb( trap - INT)
As you would guess, you can use tt(unfunction) with function-type traps;
that will correctly remove the trap as well as deleting the function.
However, `tt(trap -)' works with both, so that's the recommended way.

nsubsubsect(Limits on processes)

One other way that jobs started by the shell can be controlled is by using
limits.  These are actually limits set by the operating system, but the
shell gives you a way of controlling them: the tt(limit) and tt(unlimit)
commands.  Type `tt(limit)' on its own to see a summary.  I get:
verb(  cputime         unlimited
  filesize        unlimited
  datasize        unlimited
  stacksize       8MB
  coredumpsize    0kB
  memoryuse       unlimited
  maxproc         2048
  descriptors     1024
  memorylocked    unlimited
  addressspace    unlimited)
where the item on the left of each line is what is being limited, and on
the right is the value.  The manual page to look at, at least on Linux is
for the function tt(getrusage); that's the function the shell is calling
when you run tt(limit) or tt(unlimit).

In this case, the items are:
description(
  mydit(tt(cputime)) the total CPU time used by a process
  mydit(tt(filesize)) maximum size of a file
  mydit(tt(datasize)) the maximum size of data in use by a programme
  mydit(tt(stacksize)) the maximum size of the stack, which is the area
    of memory used to store information during function calls
  mydit(tt(coredumpsize)) the maximum size of a tt(core) file, which is
    an image of memory left by a programme that crashes, allowing you
    to debug it with tt(gdb), tt(dbx), tt(ddd) or some other debugger
  mydit(tt(memoryuse)) the maximum main memory, i.e. programme memory which
    is in active use and hasn't been `swapped out' to disk
  mydit(tt(maxproc)) the maximum number of simultaneous processes
  mydit(tt(descriptors)) the maximum number of simultaneously open
    files (`descriptors' are the internal mechanism for referring to an
    open file on UNIX-like systems)
  mydit(tt(memorylocked)) the maximum amount of memory locked in (I don't
    know what that is, either)
  mydit(tt(addressspace)) the total amount of virtual memory,
    i.e. any memory whether it is main memory, or refers to somewhere on
    a disk, or indeed anything else.
)
You may well see other names; the shell decides when it is compiled what
limits are supported by the system.

Of those, the one I use most commonly is tt(coredumpsize):  sometimes when
I'm debugging a file I want a crashed programme to produce a `tt(core)'
files so I can run tt(gdb) or tt(dbx) on it (`tt(unlimit coredumpsize)'),
while other times they are just untidy (`tt(limit coredumpsize 0)').
Probably you would only alter any of the others if you knew there was a
problem, for example a number-crunching programme used so much memory that
the rest of the system was badly affected and you wanted to limit
tt(datasize) to 64 megabyte or whatever.  You could write this as:
verb(  limit datasize 64m)

There is a distinction made between `hard' and `soft' limits.  Both have
the same effect on programmes, but you can remove or reduce `soft' limits,
while only the superuser (the system administrator's login, root) can do
that to `hard' limits.  Usually, therefore, tt(limit) and tt(unlimit)
manipulate soft limits; to show or set hard limits, give the option
tt(-h).  If I do `tt(limit -h)', I get the same list of limits as above,
but with tt(stacksize) and tt(coredumpsize) unlimited --- that means I can
reduce or remove the limits on those if I want, they're just set for my own
convenience.

Why is tt(stacksize) set in this way?  As I said, it refers to the memory
in which the functions in programmes store variables and any other local
information.  If one function calls another, it uses more memory.  You can
get into a situation where functions call themselves recursively and there
is no way out until the machine runs out of memory; limiting tt(stacksize)
prevents this.  You can actually see this with zsh itself (probably better
not to try this if you'd rather the shell you're running didn't crash):
verb(  % fn() { fn; }
  % fn)
defines a function which keeps calling itself.  To do this, all the
functions em(inside) zsh are calling themselves as well, using more and
more stack memory.  Actually, zsh uses other forms of memory inside each
function and my version of zsh crashes due to exhaustion of that memory
instead.  However, it depends on the system how this works out.

nsubsubsect(Times)

One way of returning information on process resources is with the
`tt(times)' command.  It simply shows the total CPU time used by the
shell and by the programmes called for it --- in that order, and without
description, so you need to remember.  On each line, the first number is
the time spent in user space and the second is the time spent in system
space.  If you're not concerned about the details of programmes the
difference is pretty irrelevant, but if you are, then the difference is
very roughly that between the time spent in the code you actually see
before you compile a programme, and the time spent in `hidden' code
where the system is doing something for you.  It's not such an obvious
distinction, because many library routines, such as mathematical
functions, are run in user mode as no privileged access to internal bits
of the system is required.  Typically, system time is concerned with the
details of input and output --- though even there it's not so simple,
because the C output routines tt(printf), tt(puts), tt(fread) and others
have user mode code which then calls the system routines tt(read),
tt(write) and so on.

You can measure the time taken by a particular external command by
putting `tt(time)', in the singular this time, in front of it; this is
essentially another precommand modifier, and is a shell reserved word
rather than a builtin.  This gives fairly obvious information.  You can
specify the information using the tt($TIMEFMT) parameter, which has its
own percent escapes, different from the ones used in prompts.  It exists
partly because the shell allowed you to access all sorts of other
information about the process which ran, such as `page faults' ---
occasions when the system had to fetch a part of the programme or data
from disk because it wasn't in the main memory.  However, that
disappeared because it was too much work to convert the feature to
configure itself automatically for different operating systems.  It may
be time to resurrect it.

You can also force the time to be shown automatically by setting the
parameter tt($REPORTTIME); if a command runs for more than this many
seconds, the tt($TIMEFMT) output will be shown automatically.

subsect(Terminals, users, etc.)

nsubsubsect(Watching for other users)

Although this is more associated with parameters than builtins, the
`tt(log)' command will tell you whether any of a group of people you want
to watch out for have logged in or out.  To use this, you set the tt($watch)
array parameter to a list of user names, or `tt(all)' for everyone, or
`tt(notme)' for everyone except yourself.  Even if you don't use tt(log),
any changes will be reported just before the shell prints a prompt.  It
will be printed using the tt($WATCHFMT) parameter:  once again, this takes
its own set of percent escapes, listed in the tt(zshparam) manual.

nsubsubsect(tt(ttyctl))

There is a command tt(ttyctl) which is designed to keep badly behaved
external commands from messing up the terminal settings.  Most programmes
are careful to restore any settings they change, but there are exceptions.
After `tt(ttyctl -f)', the terminal is frozen; zsh will restore the
settings, no matter what an external programme does with it.  This includes
deliberate attempts to change the terminal settings with the `tt(stty)'
command, so the default is unfrozen, `tt(ttyctl -u)'.

subsect(Syntactic oddments)

This section collects together a few builtins which, rather than
controlling the behaviour of some feature of the shell, have some other
special effect.

nsubsubsect(Controlling programme flow)

The four functions here are tt(exit), tt(return), tt(break), tt(continue)
and tt(source) or tt(.): they determine what the shell does next.  You've met
tt(exit) --- leave the shell altogether --- and tt(return) --- leave the
current function.  Be very careful not to confuse them.  Calling tt(exit)
in a shell function is usually bad:
verb(  % fn() { exit; }
  % fn)
This makes you entire shell session go away, not just the function.  If you
write C programmes, you should be very familiar with both, although there
is one difference in this case:  tt(return) at the top level in an
interactive shell actually does nothing, rather than leaving the shell as
you might expect.  However, in a script, return outside a function
em(does) cause the entire script to stop.  The reason for this is that
zsh allows you to write autoloaded functions in the same form as
scripts, so that they can be used as either; this wouldn't work if
tt(return) did nothing when the file was run as a script.  Other shells
don't do this:  tt(return) does nothing at the top level of a script, as
well as interactively.  However, other shells don't have the feature
that function definition files can be run as scripts, either.

The next two commands, tt(break) and tt(continue), are to do with
constructs like `tt(if)'-blocks and loops, and it will be much easier if I
introduce them when I talk about those below.  They will also already be
familiar to C programmers.  (If you are a FORTRAN programmer, however,
tt(continue) is em(not) the statement you are familiar with; it is instead
equivalent to tt(CYCLE) in FORTRAN90.)

The final pair of commands are tt(.) and tt(source).  They are similar to
one another and cause another file to be read as a stream of commands in
the current shell --- not as a script, for which a new shell would be
started which would finish at the end of the script.  The two are intended
for running a series of commands which have some effect on the current shell,
exactly like the startup files.  Indeed, it's a very common use to have a
call to one or other in a startup file; I have in my tt(~/.zshrc)
verb(  [[ -f ~/.aliasrc ]] && . ~/.aliasrc)
which tests if the file tt(~/.aliasrc) exists, and if so runs the commands
in it; they are treated exactly as if they had appeared directly at that
point in tt(.zshrc).

Note that your tt($path) is used to find the file to read from; this is a
little surprising if you think of this as like a script being run, since
zsh doesn't search for a script, it uses the name exactly as you gave it.
In particular, if you don't have `tt(.)' in your tt($path) and you use the
form `tt(.)' rather than `tt(source)' you will need to say explicitly when
you want to source a file in the current directory:
verb(  . ./file)
otherwise it won't be found.

It's a little bit like running a function, with the file as the function
body.  Indeed, the shell will set the positional parameters tt($*) in
just the same way.  However, there's a crucial difference: there is no
local parameter scope.  Any variables in a sourced file, as in one of
the startup files, are in the same scope as the point from which it was
started.  You can, therefore, source a file from inside a function and
have the parameters in the sourced file local, but normally the only way
of having parameters only for use in a sourced file is to unset them
when you are finished.

The fact that both tt(.) and tt(source) exist is historical:  the former
comes from the Bourne shell, and the latter from the C shell, which seems
deliberately to have done everything differently.  The point noted above,
that source always searches the current directory (and searches it first),
is the only difference.

nsubsubsect(Re-evaluating an expression)

Sometimes it's very useful to take a string and run it as if it were a set
of shell commands.  This is what tt(eval) does.  More precisely, it sticks
the arguments together with spaces and calls them.  In the case of
something like
verb(  eval print Hello.)
this isn't very useful; that's no different from a simple
verb(  print Hello.)
The difference comes when what's on the command line has something to be
expanded, like a parameter:
verb(  param='print Hello.'
  eval $param)
Here, the tt($param) is expanded just as it would be for a normal command.
Then tt(eval) gets the string `tt(print Hello.)' and executes it as shell
command line.  Everything --- really everything --- that the shell would
normally do to execute a command line is done again; in effect, it's run as
a little function, except that no local context for parameters is created.
If this sounds familiar, that's because it's exactly the way traps defined
in the form
verb(  trap 'print Hello.' EXIT)
are called.  This is one simple way out of the hole you can sometimes get
yourself into when you have a parameter which contains the name of
another parameter, instead of some data, and you want to get your hands on
the data:
verb(  # somewhere above...
  origdata='I am data.'
  # but all you know about is
  paramname=origdata
  # so to extract the data you can do...
  eval data=\$$paramname)
Now tt($data) contains the value you want.  Make sure you understand the
series of expansions going on:  this sort of thing can get very confusing.
First the command line is expanded just as normal.  This turns the argument
to tt(eval) into `tt(data=$origdata)'.  The `tt($)' that's still there was
quoted by a backslash; the backslash was stripped and the `tt($)' left; the
tt($paramname) was evaluated completely separately --- quoted characters
like the tt(\$) don't have any effect on expansions --- to give
tt(origdata).  Eval calls the new line `tt(data=$origdata)' as a command
in its own right, with the now obvious effect.  If you're even slightly
confused, the best thing to do is simply to quote everything you don't want
to be immediately expanded:
verb(  eval 'data=$'$paramname)
or even
verb(  eval 'data=${'$paramname'}')
may perhaps make your intentions more obvious.

It's possible when you're starting out to confuse `tt(eval)' with the
tt(`...`) and tt($(...)) commands, which also take the command in the
middle `tt(...)' and evaluate it as a command line.  However, these two
(they're identical except for the syntax) then insert the output of that
command back into the command line, while tt(eval) does no such thing;
it has no effect at all on where input and output go.  Conversely,
the two forms of command substitution don't do an extra level of
expansion.  Compare:
verb(  % foo='print bar'
  % eval $foo
  bar)
with
verb(  % foo='print bar'
  % echo $($foo)
  zsh: command not found: print bar
)
The tt($)LPAR()var(...)RPAR() substitution took tt($foo) as the command
line.  As you are now painfully aware, zsh doesn't split scalar
parameters, so this was turned into the single word `tt(print bar)',
which isn't a command.  The blank line is `tt(echo)' printing the empty
result of the failed substitution.

subsect(More precommand modifiers: tt(exec), tt(noglob))

Sometimes you want to run a command em(instead) of the shell.  This
sometimes happens when you write a shell script to process the arguments to
an external command, or set parameters for it, then call that command.  For
example:
verb(  export MOZILLA_HOME=/usr/local/netscape
  netscape "$@")
Run as a script, this sets an environment variable, then starts
tt(netscape).  However, as always the shell waits for the command to
finish.  That's rather wasteful here, since there's nothing more for the
shell to do; you'd rather it simply magically turned into the tt(netscape)
command.  You can actually do this:
verb(  export MOZILLA_HOME=/usr/local/netscape
  exec netscape "$@")
`tt(exec)' tells the shell that it doesn't need to wait; it can just
make the command to run replace the shell.  So this only uses a single
process.

Normally, you should be careful not to use tt(exec) interactively, since
normally you don't want the shell to go away.  One legitimate use is to
replace the current zsh with a brand new one if (say) you've set a whole
load of options you don't like and want to restore the ones you usually
have on startup:
verb(  exec zsh)
Or you may have the bad taste to start a completely different shell
altogether.  Conversely, a good piece of news about tt(exec) is that it is
common to all shells, so you can use it from another shell to start zsh in
the way I've just shown.

Like `tt(command)' and `tt(builtin)', `tt(exec)' is a `precommand modifier'
in that it alters the way a command line is interpreted.  Here's one more:
verb(  noglob print *)
If you've remembered what `glob' means, this is all fairly obvious.  It
instructs the shell not to turn the `tt(*)' into a list of all the files in
the directory, but instead to let well alone.  You can do this by quoting
the `tt(*)', of course; often tt(noglob) is used as part of an alias to set
up commands where you never need filename generation and don't want to have
to bother quoting everything.  However, note that tt(noglob) has no effect
on any other type of expansion:  parameter expansion and backquote
(tt(`....`)) expansion, for example, happen as normal; the only thing that
doesn't is turning patterns into a list of matching files.  So it doesn't
take away the necessity of knowing the rules of shell expansion.  If you
need that, the best thing to do is to use tt(read) or tt(vared) (see
below) to read a line into a parameter, which you pass to your function:
verb(  read -r param
  print $param)
The tt(-r) makes sure tt($param) is the unadulterated input.

subsect(Testing things)

I told you in the last chapter that the right way to write tests in zsh was
using the `tt([[ ... ]])' form, and why.  So you can ignore the two
builtins `tt(test)' and `tt([)', even though they're the ones that resemble
the Bourne shell.  You can safely write
verb(  if [[ $foo = '' ]]; then
    print The parameter foo is empty.  O, misery me.
  fi)
or
verb(  if [[ -z $foo ]]; then
    print Alack and alas, foo still has nothing in it.
  fi)
instead of monstrosities like
verb(  if test x$foo != x; then
    echo The emptiness of foo.  Yet are we not all empty\?
  fi)
because even if tt($foo) does expand to an empty string, which is what is
implied if the tests are true, `tt([[ ... ]])' remembers there was
something there and gets the syntax right.  Rather than a builtin, this is
actually a reserved word --- in fact it has to be, to be syntactically
special --- but you probably aren't too bothered about the difference.

There are two sorts of tests, both shown above:  those with three
arguments, and those with two.  The three-argument forms all have some
comparison in the middle; in addition to `tt(=)' (or `tt(==)', which
means the same here, and which according to the manual page we should be
using, though none of us does), there are `tt(!=)' (not equal), `tt(<)',
`tt(>)', `tt(<=)' and `tt(>=)'.  All these do em(string) comparisons,
i.e. they compare the sort order of the strings.

Since there are better ways of sorting things in zsh, the `tt(=)' and
`tt(!=)' forms are by far the most common.  Actually, they do something a
bit more than string comparison: the expression on the right can be a
pattern.  The patterns understood are just the same as for matching
filenames, except that `tt(/)' isn't special, so it can be matched by a
`tt(*)'.  Note that, because `tt(=)' and `tt(!=)' are treated specially by
the shell, you shouldn't quote the patterns:  you might think that unless
you do, they'll be turned into file names, but they won't.  So
verb(  if [[ biryani = b* ]]; then
    print Word begins with a b.
  fi)
works.  If you'd written tt('b*'), including the quotes, it wouldn't have
been treated as a pattern; it would have tested for a string which was
exactly the two letters `tt(b*)' and nothing else.  Pattern matching like
this can be very powerful.  If you've done any Bourne shell programming,
you may remember the only way to use patterns there was via the `tt(case)'
construction:  that's still in zsh (see below), and uses the same sort of
patterns, but the test form shown above is often more useful.

Then there are other three-argument tests which do numeric comparison.
Rather oddly, these use letters rather than mathematical symbols:
`tt(-eq)', `tt(-lt)' and `tt(-le)' compare if two numbers are equal, less
than, or less than or equal, to one another.  You can guess what `tt(-gt)'
and `tt(-ge)' do.  Note this is the other way round to Perl, which much
more logically uses `tt(==)' to test for equality of numbers (not `tt(=)',
since that's always an assignment operator in Perl) and `tt(eq)' (minus the
minus) to test for equality of strings.  Unfortunately we're now stuck with
it this way round.  If you are only comparing numbers, it's better to use the
`tt((( ... )))' expression, because that has a proper understanding of
arithmetic.  However,
verb(  if [[ $number -gt 3 ]]; then
    print Wow, that\'s big
  fi)
and
verb(  if (( $number > 3 )); then
    print Wow, that\'s STILL big
  fi)
are essentially equivalent.  In the second case, the status is zero (true)
if the number in the expression was non-zero (sorry if I'm confusing you
again) and vice versa.  This means that
verb(  if (( 3 )); then
    print It seems that 3 is non-zero, Watson.
  fi)
is a perfectly valid test.  As in C, the test operators in arithmetic
return 1 for true and 0 for false, i.e. `tt($number > 3)' is 1 if tt($number)
is greater than 3 and 0 otherwise; the inversion to shell logic, zero for
true, only occurs at the final step when the expression has been completely
evaluated and the `tt((( ... )))' command returns.  At least with `tt([[
... ]])' you don't need to worry about the extra negation; you can simply
think in logical terms (although that's hard enough for a lot of people).

Finally, there are a few other odd comparisons in the three-argument form:
verb(  if [[ file1 -nt file2 ]]; then
    print file1 is newer than file2
  fi)
does the test implied by the example; there is also `tt(-ot)' to test for
an older file, and there is also the little-used `tt(-ef)' which tests for
an `equivalent file', meaning that they refer to the same file --- in other
words, are linked; this can be a hard or a symbolic link, and in the second
case it doesn't matter which of the two is the symbolic link.  (If you were
paying attention above, you'll know it can't possibly matter in the first
case.)

In addition to these tests, which are pretty recognisable from most
programming languages --- although you'll just have to remember that the
`tt(=)' family compares strings and not numbers --- there are another set
which are largely peculiar to UNIXy scripting languages.  These are all in
the form of a hyphen followed by a letter as the test, which always takes a
single argument.  I showed one:  `-z $var' tests whether `tt($var)' has
zero length.  It's opposite is `-n $var' which tests for non-zero length.
Perhaps this is as good a time as any to point out that the arguments to
these commands can be any single word expression, not just variables or
filenames.  You are quite at liberty to test
verb(  if [[ -z "$var is sqrt(`print bibble`)" ]]; then
    print Flying pig detected.
  fi)
if you like.  In fact, the tests are so eager to make sure that they only
have a one word argument that they will treat things like arrays, which
usually return a whole set of words, as if they were in double quotes,
joining the bits with spaces:
verb(  array=(two words)
  if [[ $array = 'two words' ]]; then
    print "The array \$array is OK.  O, joy."
  fi)

Apart from `tt(-z)' and `tt(-n)', most of the two-argument tests are to do
with files: `tt(-e)' tests that the file named next exists, whatever type
of file it is (it might be a directory or something weirder); `tt(-f)'
tests if it exists and is a regular file (so it isn't a directory or
anything weird this time); `tt(-x)' tests whether you can execute it.
There are all sorts of others which are listed in the manual page for
various properties of files.  Then there are a couple of others: `tt(-o
<option>)' you've met and tests whether the option is set, and `tt(-t
<fd>)' tests whether the file descriptor is attached to a terminal.  A file
descriptor is a number which for the shell must be between 0 and 9
inclusive (others may exist, but you can't access them directly); 0 is the
standard input, 1 the standard output, and 2 the channel on which errors
are usually printed.  Hence `tt([[ -t 0 ]])' tests whether the input is
coming from a terminal.

There are only four other things making up tests.  `tt(&&)' and `tt(||)'
mean logical `and' and `or', `tt(!)' negates the effect of a test, and
parentheses `tt(( ... ))' can be used to surround a set of tests which are
to be treated as one.  These are all essentially the same as in C.  So
verb(  if [[ 3 -gt 2 && ( me > you || ! -z bah ) ]]; then
    print will I, won\'t I...
  fi)
will, because 3 is numerically greater than 2; the expression in
parentheses is evaluated and though `me' actually comes before `you' in the
alphabet, so the first test fails, `tt(-z bah)' is false because you gave
it a non-empty string, and hence `tt(! -z bah)' is true.  So both sides of
the `tt(&&)' are true and the test succeeds.

subsect(Handling options to functions and scripts)

It's often convenient to have your own functions and scripts process
single-letter options in the way a lot of builtin commands (as well as a
great many other UNIX-style commands) do.  The shell provides a builtin for
this called `tt(getopts)'.  This should always be called in some kind of
loop, usually a `tt(while)' loop.  It's easiest to explain by example.
verb(  testopts() {
    # $opt will hold the current option
    local opt
    while getopts ab: opt; do
      # loop continues till options finished
      # see which pattern $opt matches...
      case $opt in
        (a)
           print Option a set
           ;;
        (b)
           print Option b set to $OPTARG
           ;;
	# matches a question mark
	# (and nothing else, see text)
        (\?)
           print Bad option, aborting.
           return 1
           ;;
      esac
    done
    (( OPTIND > 1 )) && shift $(( OPTIND - 1 ))
    print Remaining arguments are: $*
  })
There's quite a lot here if you're new to shell programming.  You might
want to read the stuff on structures like tt(while) and tt(case) below
and then come back and look at this.  First let's see what it does.
verb(  % testopts -b foo -a -- args
  Option b set to foo
  Option a set
  Remaining arguments are: args)

Here's what's happening.  `tt(getopts ab: opt)' is the argument to the
`tt(while)'.  That means that the tt(getopts) gets run; if it succeeds
(returns status zero), then the loop after the `tt(do)' is run.  When
that's finished, the tt(getopts) command is run again, and so on until it
fails (returns a non-zero status).  It will do that when there are no more
options left on the command line.  So the loop processes the options one by
one.  Each time through, the number of the next argument to look at is left
in the parameter tt($OPTIND), so this gradually increases; that's how
tt(getopts) knows how far it has got.

The first argument to the tt(getopts) is `tt(ab:)'.  That means `tt(a)' is
an option which doesn't take an argument, while `tt(b)' is an argument
which takes a single argument, signified by the colon after it.  You can
have any number of single-letter (or even digit) arguments, which are
case-sensitive; for example `tt(ab:c:ABC:)' are six different options,
three with arguments.  If the option found has an argument, that is stored
in the parameter tt($OPTARG); tt(getopts) then increments tt($OPTIND) by
however much is necessary, which may be 2 or just 1 since `tt(-b foo)' and
`tt(-bfoo)' are both valid ways of giving the argument.

If an option is found, we use the `tt(case)' mechanism to find out what
it was.  The idea of this is simple, even if the syntax has the look of
an 18th-century French chateau: the argument `tt($opt)' is tested
against all of the patterns in the `tt(pattern)RPAR()' lines until one
matches, and the commands are executed until the next `tt(;;)'.  It's
the shell's equivalent of C's `tt(switch)'.  In this example, we just
print out what the tt(getopts) brought in.  Note the last line, which is
called if tt($opt) is a question mark --- it's quoted because `tt(?)' on
its own can stand for any single character.  This is how tt(getopts)
signals an unknown option.  If you try it, you'll see that tt(getopts)
prints its own error message, so ours was unnecessary: you can turn the
former off by putting a colon right at the start of the list of options,
making it `tt(:ab:)' here.

Actually, having this last pattern as an em(un)quoted `tt(?)' isn't such a
bad idea.  Suppose you add a letter to the list that tt(getopts) should
handle and forget to add a corresponding item in the tt(case) list for it.
If the last item matches any character, you will get the behaviour for an
unhandled option, which is probably the best thing to do.  Otherwise
nothing in the tt(case) list will match, the shell will sail blithely on to
the next call to tt(getopts), and when you try to use the function with the
new option you will be left wondering quite what happened to it.

The last piece of the tt(getopts) jigsaw is the next line, which tests if
tt($OPTIND) is larger than 1, i.e. an option was found and tt($OPTIND) was
advanced --- it is automatically set to 1 at the start of every function or
script.  If it was, the `tt(shift)' builtin with a numeric argument, but no
array name, moves the positional parameters, i.e. the function's arguments,
to shift away the options that have been processed.  The tt(print) in the
next line shows you that only the remaining non-option arguments are left.
You don't need to do that --- you can just start using the remaining
arguments from tt($argv[$OPTIND]) on --- but it's a pretty good way of
doing it.

In the call, I showed a line with `tt(-)tt(-)' in it: that's the standard way
of telling tt(getopts) that the options are finished; even if later words
start with a tt(-), they are not treated as options.  However, tt(getopts)
stops anyway when it reaches a word not beginning with `tt(-)', so that
wasn't necessary here.  But it works anyway.

You can do all of what tt(getopts) does without em(that) much difficulty
with a few extra lines of shell programming, of course.  The best argument
for using tt(getopts) is probably that it allows you to group single-letter
options, e.g. `tt(-abc)' is equivalent to `tt(-a -b -c)' if none of them
was defined to have an argument.  In this case, tt(getopts) has to remember
the position em(inside) the word on the command line for you to call it
next, since the `tt(a)' `tt(b)' and `tt(c)' still appear on different
calls.  Rather unsatisfactorily, this is hidden inside the shell (as it is
in other shells --- we haven't fixed em(all) of everybody else's bad design
decisions); you can't get at it or reset it without altering tt($OPTIND).
But if you read the small print at the top of the guide, you'll find I
carefully avoided saying everything was satisfactory.

While we're at it, why do blocks starting with `tt(if)' and `tt(then)' end
with `tt(fi)', and blocks starting with `tt(case)' end with `tt(esac)',
while those starting with `tt(while)' and `tt(do)' end with `tt(done)', not
`tt(elihw)' (perfectly pronounceable in Welsh, after all) or `tt(od)'?
Don't ask me.

subsect(Random file control things)

We're now down into the odds and ends.  If you know UNIX at all, you will
already be familiar with the tt(umask) command and its effect on file
creation, but as it is a builtin I will describe it here.  Create a file
and look at it:
verb(  % touch tmpfile
  % ls -l tmpfile
  -rw-r--r--    1 pws   pws    0 Jul 19 21:19 tmpfile)
(I've shortened the output line for the TeX version of this document.)
You'll see that the permissions are read for everyone, write-only for the
owner.  How did the command (tt(touch), not a builtin, creates an empty
file if there was none, or simply updates the modification time of an
existing file) know what permissions to set?
verb(  % umask
  022
  % umask 077
  % rm tmpfile; touch tmpfile
  % ls -l tmpfile
  -rw-------    1 pws   pws    0 Jul 19 21:22 tmpfile)
tt(umask) was how it knew.  It gives an octal number corresponding to the
permissions which should em(not) be given to a newly created file (only
newly created files are affected; operations on existing files don't
involve tt(umask)).  Each digit is made up of a 4 for read, 2 for write, 1
for executed, in the same order that tt(ls) shows for permissions: user,
then group, then everyone else.  (On this Linux/GNU-based system, like many
others, users have their own groups, so both are called `tt(pws)'.)
So my original `022' specified that everything should be allowed except
writing for group and other, while `077' disallowed any operation by group
and other.  These are the two most common settings, although here `002' or
`007' would be useful because of the way groups are specific to users,
making it easier to grant permission to specific other users to write in
my directories.  (Except there aren't any other users.)

You can also use tt(chmod)-like permission changing expressions in
tt(umask).  So
verb(  % umask go+rx)
would restore group and other permissions for reading and executing, hence
returning the mask to 022.  Note that because it is em(adding) permissions,
just like tt(chmod) does, it is em(removing) numbers from the umask.

You might have wondered about execute permissions, since `tt(touch)'
didn't give any, even where it was allowed by tt(umask).  That's because
only operations which create executable programmes, such as running a
compiler and linker, set that bit; the normal way of opening a new file
--- internally, the UNIX tt(open) function, with the tt(O_CREAT) flag
set --- doesn't touch it.  For the same reason, if you create shell
scripts which you want to be able to execute by typing the name, you
have to make them executable yourself:
verb(  % chmod +x myscript)
and, indeed, you can think of tt(chmod) as tt(umask)'s companion for
files which already exist.  It doesn't need to be a builtin, because the
files you are operating on are external to tt(zsh); tt(umask), on the
other hand, operates when you create a file from within tt(zsh) or any
child process, so needs to be a builtin.  The fact that it's inherited
means you can set tt(umask) before you start an editor, and files
created by that editor will reflect the permissions.

Note that the value set by tt(umask) is also inherited and used by
tt(chmod).  In the example of tt(chmod) I gave, I didn't see em(which)
type of execute permission to add; tt(chmod) looks at my tt(umask) and
decides based on that --- in other words, with 022, everybody would be
allowed to execute tt(myscript), while with 077, only I would, because
of the 1's in the number: (0+0+0)+(4+2+1)+(4+2+1).  Of course, you can
be explicit with chmod and say `tt(chmod u+x myscript)' and so on.

Something else that may or may not be obvious:  if you run a script by
passing it as an argument to the shell,
verb(  % zsh myscript)
what matters is em(read) permission.  That's what the shell's doing to the
script to find the commands, after all.  Execute permission applies when
the system (or, in some cases, including zsh, the parent shell where you
typed `tt(myscript)') has to decide whether to find a shell to run the
script by itself.

subsect(Don't watch this space, watch some other)

Finally for builtins, some things which really belong elsewhere.  There are
three commands you use to control the shell's editor.  These will be
described in lref(chapter)(zle), where I talk all about the editor.

The tt(bindkey) command allows you to attach a set of keystrokes to a
command.  It understands an abbreviated notation for the keystrokes.
verb(  % bindkey '^Xc' copy-prev-word)
This binds the keystrokes consisting of tt(Ctrl) held down with tt(x), then
tt(c), to the command which copies the previous word on the line to the
current position.  The commands are listed in the tt(zshzle) manual page.
tt(bindkey) can also do things with keymaps, which are a complete set of
mappings between keys and commands like the one I showed.

The tt(vared) command is an extremely useful builtin for editing a shell
variable.  Usually much the easiest way to change tt($path) (or tt($PS1),
or whatever) is to run `tt(vared path)':  note the lack of a `tt($)', since
otherwise you would be editing whatever tt($path) was expanded to.  This
is because very often you want to leave most of what's there and just
change the odd character or word.  Otherwise, you would end up doing this
with ordinary parameter substitutions, which are a lot more complicated and
error prone.  Editing a parameter is exactly like editing a command line,
except without the prompt at the start.

Finally, there is the tt(zle) command.  This is the most mysterious, as it
offers a fairly low-level interface to the line editor; you use it to
define your own editing commands.  So I'll leave this alone for now.

subsect(And also)

There is one more standard builtin that I haven't covered: tt(zmodload),
which allows you to manipulate add-on packages for zsh.  Many extras are
supplied with the shell which aren't normally loaded to keep down the use
of memory and to avoid having too many rarely used builtins, etc., getting
in the way.  In the last chapter I will talk about some of these.  To be
more honest, a lot of the stuff in between actually uses these addons,
generically referred to as modules --- the line editor, zle, is itself a
separate module, though heavily dependent on the main shell --- and you've
probably forgotten I mentioned above using `tt(zmodload zsh/mathfunc)' to
load mathematical functions.

sect(Functions)

Now it's time to look at functions in more detail.  The various issues
to be discussed are: loading functions, handling parameters, compiling
functions, and repairing bike tyres when the rubber solution won't stick
to the surface.  Unfortunately I've already used so much space that I'll
have to skip the last issue, however topical it might be for me at the
moment.

subsect(Loading functions)

Well, you know what happens now.  You can define functions on the command
line:
verb(  fn() {
    print I am a function
  })
which you call under the name `tt(fn)'.  As you type, the shell knows that
it's in the middle of a function definition, and prompts you until you get
to the closing brace.

Alternatively, and much more normally, you put a file called tt(fn)
somewhere in a directory listed in the tt($fpath) array.  At this point,
you need to be familiar with the tt(KSH_AUTOLOAD) option described in the
last chapter.  From now on, I'm just going to assume your autoloadable
function files contain just the body of the function, i.e. tt(KSH_AUTOLOAD)
is not set.  Then the file tt(fn) would contain:
verb(  print I am a function)
and nothing else.

Recent versions of zsh, since tt(3.1.6), set up tt($fpath) for you.  It
contains two parts, although the second may have multiple directories.
The first is, typically, tt(/usr/local/share/zsh/site-functions),
although the prefix may vary.  This is empty unless your system
administrator has put something in it, which is what it's there for.

The remaining part may be either a single directory such as
tt(/usr/local/share/zsh/3.1.9/functions), or a whole set of directories
starting with that path.  It simply depends whether the person
installing zsh wanted to keep all the functions in the same directory,
or have them sorted according to what they do.  These directories are
full of functions.  However, none of the functions is autoloaded
automatically, so unless you specifically put `tt(autoload ...)' in a
startup file, the shell won't actually take any notice of them.  As
you'll see, part of the path is the shell version.  This makes it very
easy to keep multiple versions of zsh with functions which use features
that may be different between the two versions.  By the way, if these
directories don't exist, you should check tt($fpath) to see if they are
in some other location, and if you can't find any correspondence between
what's in tt($fpath) and what's on the disk even when you start the
shell with tt(zsh -f) to suppress loading of startup files, complain to
the system administrator: he or she has either not installed them
properly, or has made tt(/etc/zshenv) stomp on tt($fpath), both of which
are thoroughly evil things to do.  (tt(/etc/zshrc), tt(/etc/zprofile)
and tt(/etc/zlogin) shouldn't stomp on tt($fpath) either, of course.  In
fact, they shouldn't do very much; that's up to the user.)

One point about tt(autoload) is the `tt(-U)' option.  This turns off the
use of any aliases you have defined when the function is actually loaded
--- the flag is remembered with the name of the function for future
reference, rather than being interpreted immediately by the tt(autoload)
command.  Since aliases can pretty much redefine any command into any
other, and are usually interpreted while a function is being defined or
loaded, you can see that without this flag there is fair scope for
complete havoc.
verb(   alias ls='echo Your ls command has been requisitioned.'
   lsroot() {
     ls -l /
   }
   lsroot)
That's not what the function writer intended.  (Yes, I know it actually
em(is), because I wrote it to show the problem, but that's not what I
em(meant).) So tt(-U) is recommended for all standard functions, where you
have no easy way of telling quite what could be run inside.

Recently, the functions for the new completion system (described in 
lref(chapter)(comp)) have been changing the fastest.  They either begin
with tt(comp) or an underscore, `tt(_)'.  If the tt(functions) directory
is subdivided, most of the subdirectories refer to this.  There are
various other classes of functions distributed with the shell:
startit()
  it() Functions beginning tt(zf) are associated with zftp, a builtin
  system for FTP transfers.  Traditional FTP clients, ones which don't
  use a graphical interface, tend to be based around a set of commands
  on a command line --- exactly what zsh is good at.  This also makes it
  very easy to write macros for FTP jobs --- they're just shell
  functions.  This is described in the final chapter along with other
  modules.  It's based around a single builtin, tt(zftp), which is
  loaded from the module tt(zsh/zftp).

  it() Functions beginning tt(prompt), which may be in the tt(Prompts)
  subdirectory, are part of a `prompt themes' system which makes it
  easy for you to switch between preexisting prompts.  You load it
  with `tt(autoload -U promptinit; promptinit)'.   Then `tt(prompt -h)'
  will tell you what to do next.  If you have new completion loaded
  (with `tt(autoload -U compinit; compinit)', what else) the arguments
  to `tt(prompt)' can be listed with tt(^D) and completed with a TAB;
  they are various sorts of prompt which you may or may not like.

  it() Functions with long names and hyphens, like tt(predict-on) and
  tt(incremental-complete-word).  These are editor functions; you use them
  with
verb(  zle -N predict-on
  bindkey <keystroke> predict-on)
  Here, the tt(predict-on) function automatically looks back in the history
  list for matching lines as you type.  You should also bind
  tt(predict-off), which is loaded when tt(predict-on) is first called.
  tt(incremental-complete-word) is a fairly simple attempt at showing
  possible completions for the current word as you type; it could do with
  improving.

  it() Everything else; these may be in the tt(Misc) subdirectory.  These
  are a very mixed bag which you should read to see if you like any.  One
  of the most useful is tt(zed), which allows you to edit a small file
  (it's really just a simple front-end to tt(vared)).  The tt(run-help)
  file shows you the sort of thing you might want to define for use with
  the tt(\eh) (tt(run-help)) keystroke.  tt(is-at-least) is a function
  for finding out if the version of the shell running is recent enough,
  assuming you know what version you need for a given feature.  Several of
  the other functions refer to the old completion system --- which you
  won't need, since you will be reading lref(chapter)(comp) and using
  the new completion system, of course.
endit()

If you have your own functions --- and if you use zsh a lot, you almost
certainly will eventually --- it's a good idea to add your own personal
directory to the front of tt($fpath), so that everything there takes
precedence over the standard functions.  That allows you to override a
completion function very easily, just by copying it and editing it.  I tend
to do something like this in my tt(.zshenv):
verb(  [[ $fpath = *pws* ]] || fpath=(~pws/bin/fns $fpath))
to protect against the possibility that the directory I want to add is
already there, in case I source that startup file again, and there are
other similar ways.  (You may well find your own account isn't called
tt(pws), however.)

Chances are you will always want your own functions to be autoloaded.
There is an easy way of doing this:  put it just after the line I showed
above:
verb(  autoload ${fpath[1]}/*(:t))
The tt(${fpath[1]}/*) expands to all the files in the directory at the head
of the tt($fpath) array.  The tt((:t)) is a `glob modifier': applied to a
filename generation pattern, it takes the tail (basename) of all the files
in the list.  These are exactly the names of the functions you want to
autoload.  It's up to you whether you want the tt(-U) argument here.

subsect(Function parameters)

I covered local parameters in some detail when I talked about tt(typeset),
so I won't talk about that here.  I didn't mention the other parameters
which are effectively local to a function, the ones that pass down the
arguments to the function, so here is more detail.  They work pretty much
identically in scripts.

There are basically two forms.  There is the form inherited from Bourne
shell via Korn shell, with the typically uninformative names: tt($#),
tt($*), tt($@) and the numerical parameters tt($1) etc. --- as high a
number as the shell will parse is allowed, not just single digits.  Then
there is the form inherited from the C shell: tt($ARGC) and tt($argv).
I'll mainly use the Bourne shell versions, which are far more commonly
used, and come back to some oddities of the C shell variety at the end.

tt($#) tells you how many arguments were passed to the function, while
tt($*) gives those arguments as an array.  This was the only array
available in the Bourne shell, otherwise there would probably have been a
more obvious way of doing it.  To get the size and the number of elements
of the array you don't use tt(${#*}) and tt(${*[1]}) etc. (well, you usually
don't --- zsh is typically permissive here), you use tt($1), tt($2).
Despite the syntax, these are rather like ordinary array elements; if you
refer to one off the end, you will get an empty string, but no error,
unless you have the option tt(NO_UNSET) set.  It is this not-quite array
which gets shifted if you use the tt(shift) builtin without an argument:
the old tt($1) disappears, the old tt($2) becomes tt($1), and so on, while
tt($#) is reduced by one.  If there were no arguments (tt($#) was zero),
nothing happens.

The form tt($@) is very similar to tt($*), and you can use it in place of
that in most contexts.  There is one place where they differ.  Let's define
a function which prints the number of its arguments, then the arguments.
verb(  args() {
    print $# $*
  })
Now some arguments.  We'll do this for the current shell --- it's a
slightly odd idea, that you can set the arguments for what's already
running, or that an interactive shell has arguments at all, but
nonetheless it's true:
verb(  set arguments to the shell
  print $*)
sets tt($*) and hence prints the message `tt(arguments to the shell)'.  We
now pass em(these) arguments on to the function in two different ways:
verb(  args $*
  args $@)
This outputs
verb(  4 arguments to the shell
  4 arguments to the shell)
-- no surprises so far.  Remember, too, that zsh doesn't split words on
spaces unless you ask it too.  So:
verb(  % set 'one word'
  % args $*
  1 one word
  % args $@
  1 one word)

Now here's the difference:
verb(  % set two words
  % args "$*"
  1 two words
  % args "$@"
  2 two words)
In quotes, tt("$*") behaves as a normal array, joining the words with
spaces.  However, tt("$@") doesn't --- it still behaves as if it was
unquoted.  You can't see from the arguments themselves in this case, but
you can from the digit giving the number of arguments the function has.

This probably seems pretty silly.  Why quote something to have it behave
like an unquoted array?  The original answer lies back in Bourne shell
syntax, and relates to the vexed question of word splitting.  Suppose we
turn on Bourne shell behaviour, and try the example of a word with spaces
again:
verb(  % setopt shwordsplit
  % set 'one word'
  % args $*
  2 one word
  % args $@
  2 one word
  % args "$*"
  1 one word
  % args "$@"
  1 one word)
Aha!  em(This) time tt("$@") kept the single word with the space intact.
In other words, tt("$@") was a slightly primitive mechanism for suppressing
splitting of words, while allowing the splitting of arrays into elements.
In zsh, you would probably quite often use tt($*), not tt("$@"), safe in
the knowledge that nothing was split until you asked it to be; and if you
wanted it split, you would use the special form of substitution tt(${=*})
which does that:
verb(  % unsetopt shwordsplit
  % args $*
  1 one word
  % args ${=*}
  2 one word)
(I can't tell you why the `tt(=)' was chosen for this purpose, except that
it consists of two split lines, or in an assignment it splits two things,
or something.)  This works with any parameter, whether scalar or array,
quoted or unquoted.

However, that's actually not quite the whole story.  There are times when
the shell removes arguments, because there's nothing there:
verb(  % set hello '' there
  % args $*
  2 hello there)
The second element of the array was empty, as if you'd typed
verb(  2=)
--- yes, you can assign to the individual positional parameters directly,
instead of using tt(set).  When the array was expanded on the command line,
the empty element was simply missed out altogether.  The same happens with
all empty variables, including scalars:
verb(  % empty=
  % args $empty
  0)
But there are times when you don't want that, any more than you want word
splitting --- you want em(all) arguments passed just as you gave them.
This is another side effect of the tt("$@") form.
verb(  % args "$@"
  3 hello there)
Here, the empty element was passed in as well.  That's why you often find
tt("$@") being used in zsh when wordsplitting is already turned off.

Another note: why does the following not work like the example with tt($*)?
verb(  % args hello '' there
  3 hello there)
The quotes were kept here.  Why?  The reason is that the shell doesn't
elide an argument if there were quotes, even if the result was empty:
instead, it provides an empty string.  So this empty string was passed as
the second argument.  Look back at:
verb(  set hello '' there)
Although you probably didn't think about it at the time, the same thing was
happening here.  Only with the tt(')tt(') did we get an empty string assigned
to tt($2); later, this was missed out when passing tt($*) to the function.
The same difference occurs with scalars:
verb(  % args $empty
  0
  % args "$empty"
  1)
The tt($empty) expanded to an empty string in each case.  In the first case
it was unquoted and was removed; this is like passing an empty part of
tt($*) to a command.  In the second case, the quotes stopped that from
being removed completely; this is similar to setting part of tt($*) to an
empty string using tt('').

That's all thoroughly confusing the first time round.  Here's a table
to try and make it a bit clearer.
verb(                       |   Number of arguments
                       |     if $* contains...
                       |  (two words)
Expression   Word      |       'one word'
on line   splitting?   |             empty string
--------------------------------------------------
$*             n       |     2     1     0
$@             n       |     2     1     0
"$*"           n       |     1     1     1
"$@"           n       |     2     1     1
                       |                    
$*             y       |     2     2     0
$@             y       |     2     2     0
"$*"           y       |     1     1     1
"$@"           y       |     2     1     1
                       |                    
${=*}          n       |     2     2     0
${=@}          n       |     2     2     0
"${=*}"        n       |     2     2     1
"${=@}"        n       |     2     2     1)
On the left is shown the expression to be passed to the function, and in
the three right hand columns the number of arguments the function will get if
the positional parameters are set to an array of two words, a single
word with a space in the middle, or a single word which is an empty string
(the effect of `tt(set -- ')tt(')') respectively.  The second column shows
whether word splitting is in effect, i.e. whether the tt(SH_WORD_SPLIT)
option is set.  The first four lines show the normal zsh behaviour; the
second four show the normal sh/ksh behaviour, with word splitting turned
on --- only the case where a word has a space in it changes, and then
only when no quotes are supplied.  The final four show what happens when
you use the `tt(${=..})' method to turn on word splitting, for
convenience: that's particularly simple, since it always forces words to
be split, even inside quotation marks.

I would recommend that anyone not wedded to the Bourne shell behaviour use
the top set as standard: in particular, `tt($*)' for normal array behaviour
with removal of empty items, `tt("$@")' for normal array behaviour with
empty items left as empty items, and `tt("$*")' for turning arrays into
single strings.  If you need word-splitting, you should use `tt(${=*})' or
`tt("${=@}")' for splitting with/without removal of empty items (obviously
there's no counterpart to the quoted-array behaviour here).  Then keep
tt(SH_WORD_SPLIT) turned off.  If you are wedded to the Bourne shell
behaviour, you're on your own.

nsubsubsect(It's a bug)

There's a bug in handling of the the form tt(${1+"$@"}).  This looks
rather an arcane and unlikely combination, but actually it is commonly
used to get around a bug in some versions of the Bourne shell (which is
not in zsh): that tt("$@") generates a single empty argument if there
are no arguments.  The form shown tests whether there is a first
argument, and if so substitutes tt("$@"), else it doesn't substitute
anything, avoiding the bug.

Unfortunately, in zsh, when tt(shwordsplit) is set --- which is the time
you usually run across attempts like this to standardise the way
different shells work --- this will actually cause too much
word-splitting.  The way the shell is written at the moment, the
embedded tt("$@") will force extra splitting on spaces inside the
arguments.  So if the first argument is `tt(one word)', and
tt(shwordsplit) is set, tt(${1+"$@"}) produces em(two) words `tt(one)'
and `tt(word)'.

Oliver Kiddle spotted a way of getting round this which has been adapted
for use in the GNU autoconf package:  in your initialisation code, have
verb(  [ x$ZSH_VERSION != x ] && alias -g '${1+"$@"}'='"$@"')
This uses a global alias to turn tt(${1+"$@"}) wherever it occurs as a
single word into tt("$@") which doesn't have the problem.  Aliasing
occurs so early in processing that the fact that most of the characters
have a special meaning to the shell is irrelevant; the shell behaves as
if it read in tt("$@").  The only catch is that for this to work the
script or function must use em(exactly) the character string
tt(${1+"$@"}), with no leading or trailing word characters (whitespace,
obviously, or characters which terminate parsing such as `tt(;)' are all
right).  Some day, we may fix the underlying bug, but it's not very easy
with the way the parameter substitution code is written at the moment.

nsubsubsect(Parameters inherited from csh)

The final matter is the C-shell syntax.  There are two extra variables
but, luckily, there is not much extra in the way of complexity.
tt($ARGC) is essentially identical to tt($#), and tt($argv) corresponds
to tt($*), but is a real array this time, so instead of tt($1) you have
tt(${argv[1]}) and so on.  They use the convention that scalars used by
the shell are all uppercase, while arrays are all lowercase.  This
feature is probably the only reason anyone would need these variants.
For example, tt(${argv[2,-1]}) means all arguments from the second to
the last, inclusive: negative indices count from the end, and a comma
indicates a slice of an array, so that tt(${argv[1,-1]}) is always the
same as the full array.  Otherwise, my advice would be to stick with the
Bourne shell variants, however cryptic they may look at first sight, for
the usual reason that zsh isn't really like the C shell and if you
pretend it is, you will come a cropper sooner or later.

It looks like you're missing tt("$@"), but actually you can do that with
tt("${argv[@]}").  This, like negative indices and slices, works with all
arrays.

There's one slight oddity with tt($ARGC) and tt($argv), which isn't
really a deliberate feature of the shell at all, but just in case you
run into it:  although the values in them are of course local to
functions, the variables tt($ARGC) and tt($argv) em(themselves) are
actually treated like global variables.  That means if you apply a
tt(typeset -g) command to them, it will affect the behaviour of
tt($ARGC) and tt($argv) in all functions, even though they have
different values.  It's probably not a good idea to rely on this
behaviour.

nusubsect(Arguments to all commands work the same)

I've been a little tricky here, because I've been talking about two levels
of functions at once:  tt($*) and friends as set in the current function,
or even at the top level, as well as how they are passed down to commands
such as my tt(args) function.  Of course, in the second case the same
behaviour applies to all commands, not just functions.  What I mean is, in
verb(  fn() {
    cat $*
    cat "$*"
  })
the `tt(cat)' command will see the differences in behaviour between the two
calls just as tt(args) would.  That should be obvious.

nsubsubsect(It's not a bug)

Let me finally mention again a feature I noted in passing:
verb(  1='first argument')
sets the first command argument for the current shell or function,
independently of any others.  People sometimes complain that
verb(  1000000='millionth argument')
suddenly makes the shell use a lot more memory.  That's not a bug at
all:  you've asked the shell to set the millionth element of an array,
but not any others, so the shell creates an array a million elements
long with the first 999,999 empty, except for any arguments which were
already set.  It's not surprising this takes up a lot of memory.

subsect(Compiling functions)

Since version 3.1.7, it has been possible to compile functions to their
internal format.  It doesn't make the functions run any faster, it just
reduces their loading time; the shell just has to bring the function
into memory, then it `runs it as it does any other function.  On many
modern computers, therefore, you don't gain a great deal from this.  I
have to admit I don't use it, but there are other definite advantages.

Note that when I say `compiled' I don't mean the way a C compiler, say,
would take a file and turn it into the executable code which the
processor understands; here, it's simply the format that the shell
happens to use internally --- it's useless without a suitable version of
zsh to run it.  Also, it's no use thinking you can hide your code from
prying eyes this way, like you can to some extent with an ordinary
compiler (disassembling anything non-trivial from scratch being a
time-consuming job): first of all, ordinary command lines appear inside
the compiled files, except in slightly processed form, and secondly
running `tt(functions)' on a compiled function which has been loaded
will show you just as much as it would if the function had been loaded
normally.

One other advantage is that you can create `digest' files, which are
sets of functions stored in a single file.  If you often use a large
fraction of those files, or they are small, or you like the function
itself to appear when you run `functions' rather than a message saying
it hasn't been loaded, then this works well.  In fact, you can compile
all the functions in a single directory in one go.  You might think this
uses a lot of memory, but often zsh will simply `memory map' the file,
which means rather than reserving extra main memory for it and reading
it in --- the obvious way of reading files --- it will tell the
operating system to make the file available as if it were memory, and
the system will bring it into memory piece by piece, `paging' the file
as it is needed.  This is a very efficient way of doing it.  Actually,
zsh supports both this method and the obvious method of simply reading
in the file (as long as your operating system does); this is described
later on.

A little extra, in case you're interested: if you read in a file
normally, the system will usually reserve space on a disk for it, the
`swap', and do paging from there.  So in this case you still get the
saving of main memory --- this is standard in all modern operating
systems.  However, it's not em(as) efficient: first of all, you had to
read the file in in the first place.  Secondly it eats up swap space,
which is usually a fixed amount of disk, although if you've got enough
main memory, the system probably won't bother allocating swap.  Thirdly
--- this is probably the clincher for standard zsh functions on a large
system --- if the file is directly mapped read-only, as it is in this
case, the system only needs one place in main memory, plus the single
original file on disk, to keep the function, which is very much more
efficient.  With the other method, you would get multiple copies in both
main memory and (where necessary) swap.  This is how the system treats
directly executable programmes like the shell itself --- the data is
specific to each process, but the programme itself can be shared because
it doesn't need to be altered when it's running.

Here's a simple example.
verb(  % echo 'echo hello, world' >hw
  % zcompile hw
  % ls
  hw    hw.zwc
  % rm hw
  % fpath=(. $fpath)
  % autoload hw
  % hw
  hello, world)
We created a simple `hello, world' function, and compiled it.  This
produces a file called `tt(hw.zwc)'.  The extension stands for `Z-shell
Word Code', because it's based on the format of words (integers longer
than a single byte) used internally by the shell.  Then we made sure the
current directory was in our tt($fpath), and autoloaded the function,
which ran as expected.  We deleted the original file for demonstration
purposes, but as long as the `tt(.zwc)' file is newer, that will be
used, so you don't need to remove the originals in normal use.  In fact,
you shouldn't, because you will lose any comments and formatting
information in it; you can regenerate the function itself with the
`tt(functions)' command (try it here), but the shell only remembers the
information actually needed to run the commands.  Note that the function
was in the zsh autoload format, not the ksh one, in this case (but see
below).

nsubsubsect(And there's more)

Now some bells and whistles.  Remember the tt(KSH_AUTOLOAD) thing?  When
you compile a function, you can specify which format --- native zsh or
ksh emulation --- will be used for loading it next time, by using the
option tt(-k) or tt(-z), instead of the default, which is to examine the
option (as would happen if you were autoloading directly from the file).
Then you don't need to worry about that option.  So, for example, you
could compile all the standard zsh functions using `tt(zcompile -z)' and
save people the trouble of making sure they are autoloaded correctly.

You can also specify that aliases shouldn't be expanded when the files
are compiled by using tt(-U): this has roughly the same effect as saying
tt(autoload -U), since when the shell comes to load a compiled file, it
will never expand aliases, because the internal format assumes that all
processing of that kind has already been done.  The difference in this
case is if you em(don't) specify tt(-U): then the aliases found when you
compile the file, not when you load the function from it, will be used.

Now digest files.  Here's one convenient way of doing it.
verb(  % ls ~/tmp/fns
  hw1   hw2
  % fpath=(~/tmp/fns $fpath)
  % cd ~/tmp
  % zcompile fns fns/*
  % ls
  fns   fns.zwc)
We've made a directory to put functions in, tt(~/tmp/fns), and stuck some
random files in it.  The tt(zcompile) command, this time, was given several
arguments: a filename to use for the compiled functions, and then a list of
functions to compile into it.  The new file, tt(fns.zwc), sits in the same
directory where the directory tt(fns), found in tt($fpath), is.  The shell
will actually search the digest file instead of the directory.  More
precisely, it will search both, and see which is the more recent, and use
that as the function.  So now
verb(  % autoload hw1
  % hw1
  echo hello, first world)

You can test what's in the digest file with:
verb(  % zcompile -t fns
  zwc file (read) for zsh-3.1.9-dev-3
  fns/hw1
  fns/hw2)
Note that the names appear as you gave them on the command line,
i.e. with tt(fns/) in front.  Only the basenames are important for
autoloading functions.  The note `tt((read))' in the first line means
that zsh has marked the functions to be read into the shell, rather than
memory mapped as discussed above; this is easier for small functions,
particularly if you are liable to remove or alter a file which is
mapped, which will confuse the shell.  It usually decides which method
to use based on size; you can force memory mapping by giving the tt(-M)
option.  Memory mapping doesn't work on all systems (currently including
Cygwin).

I showed this for compiling files, but you can actually tell the shell
to output compiled functions --- in other words, it will look along
tt($fpath) and compile the functions you specify.  I find compiling
files easier, when I do it at all, since then I can use patterns to find
them as I did above.  But if you want to do it the other way, you should
note two other options: tt(-a) will compile files by looking along
tt($fpath), while tt(-c) will output any functions already loaded by the
shell (you can combine the two to use either).  The former is
recommended, because then you don't lose any information which was
present in the autoload file, but not in the function stored in memory
---- this is what would happen if the file defined some extra widgets
(in the non-technical sense) which weren't part of the function called
subsequently.

If you're perfectly happy with the shell em(only) searching a digest
file, and not comparing the datestamp with files in the directory, you
can put that directly into your tt($fpath), i.e. tt(~/tmp/fns.zwc) in
this case.  Then you can get rid of the original directory, or archive
it somewhere for reuse.

You can compile scripts, too.  Since these are in the same format as a
zsh autoload file, you don't need to do anything different from
compiling a single function.  You then run (say) tt(script.zwc) by
typing `tt(zsh script)' --- note that you should omit the tt(.zwc), as
zsh decides if there's a compiled version of a script by explicitly
appending the suffix.  What's more, you can run it using `tt(.)' or
`tt(source)' in just the same way (`tt(. script)') --- this means you
can compile your startup files if you find they take too long to run
through; the shell will spot a tt(~/.zshrc.zwc) as it would any other
sourceable file.  It doesn't make much sense to use the memory mapping
method in this case, since once you've sourced the files you never want
to run them again, so you might as well specify `tt(zcompile -R)' to use
the reading (non-memory-mapping) method explicitly.

If you ever look inside a tt(.zwc) file, you will see that the
information is actually included twice.  That's because systems differ
about the order in which numbers are stored: some have the least
significant byte first (notably Intel and some versions of Mips) and
some the most significant (notably SPARC and Cambridge Consultants' XAP
processor, which is notable here mainly because I spend my working hours
programming for it --- you can't run zsh on it).  Since zsh uses
integers a great deal in the compiled code, it saves them in both
possible orders for ease of use.  Why not just save it for the machine
where you compiled it?  Then you wouldn't be able to share the files
across a heterogeneous network --- or even worse, if you made a
distribution of compiled files, they would work on some machines, and
not on others.  Think how Emacs users would complain if the tt(.elc)
files that arrived weren't the right ones.  (Worse, think how the vi
users would laugh.)  The shell never reads or maps in the version it
doesn't use, however; only extra disk space is used.

nsubsubsect(A little -Xtra help)

There are two final autoloading issues you might want to know about.  In
versions of zsh since 3.1.7, you will see that when you run
tt(functions) on a function which is marked for autoload but hasn't yet
been loaded, you get:
verb(afunctionmarkedforautoloadwhichhasntbeenloaded () {
        # undefined
        builtin autoload -XU
})
The `tt(# undefined)' is just printed to alert you that this was a
function marked as autoloadable by the tt(autoload) command: you can
tell, because it's the only time tt(functions) will emit a comment
(though there might be other `tt(#)' characters around).  What's
interesting is the tt(autoload) command with the tt(-X) option.  That
option means `Mark me for autoloading and run me straight away'.  You
can actually put it in a function yourself, and it will have the same
effect as running `tt(autoload)' on a not-yet-existent
function. Obviously, the tt(autoload) command will disappear as soon as
you do run it, to be replaced by the real contents.  If you put this
inside a file to be autoloaded, the shell will complain --- the
alternative is rather more unpalatable.

Note also the tt(-U) option was set in that example:  that simply means
that I used tt(autoload) with the tt(-U) option when I originally told
the shell to autoload the function.

There's another option, tt(+X), the complete opposite of tt(-X).  This
one can em(only) be used with autoload outside the function you're
loading, just as tt(-X) was only meaningful inside.  It means `load the
file immediately, but don't run it', so it's a more active (or, as they
say nowadays, since they like unnecessarily long words, proactive) form
of tt(autoload).  It's useful if you want to be able to run the
tt(functions) command to see the function, but don't want to run the
function itself.

nsubsubsect(Special functions)

I'm in danger of simply quoting the manual, but there are various
functions with a special meaning to the shell (apart from tt(TRAP...)
functions, which I've already covered).  That is, the functions
themselves are perfectly normal, but the shell will run them
automatically on certain occasions if they happen to exist, and silently
skip them if they don't.

The two most frequently used are tt(chpwd) and tt(precmd).  The former
is called whenever the directory changes, either via tt(cd), or
tt(pushd), or an tt(AUTO_CD) --- you could turn the first two into
functions, and avoid needing tt(chpwd) but not the last.  Here's how to
force an xterm, or a similar windowing terminal, to put the current
directory into the title bar.
verb(  chpwd() {
    [[ -t 1 ]] || return
    case $TERM in
      (sun-cmd) print -Pn "\e]l%~\e\\"
        ;;
      (*xterm*|rxvt|(dt|k|E)term) print -Pn "\e]2;%~\a"
        ;;
    esac
  })
The first line tests that standard output is really a terminal --- you
don't want to print the string in the middle of a script which is
directing its output to a file.  Then we look to see if we have a
tt(sun-cmd) terminal, which has its own em(sui generis) sequence for
putting a string into the title bar, or something which recognises xterm
escape sequences.  In either case, the special sequences (a bit like
termcap sequences as discussed for tt(echotc)) are interpreted by the
terminal, and instead of being printed out cause it to put the string in
the middle into the title bar.  The string here is `tt(%~)': I added the
tt(-P) option to tt(print) so it would expand prompt escapes.  I could
just have used tt($PWD), but this way has the useful effect of
shortening your home directory, or any other named directory, into
tt(~)-notation, which is a bit more readable.  Of course, you can put
other stuff there if you like, or, if you're really sophisticated, put
in a parameter tt($HEADER) and define that elsewhere.

If programmes other than the shell alter what appears in the xterm title
bar, you might consider changing that tt(chwpd) function to tt(precmd).
The function tt(precmd) is called just before every prompt; in this case
it will restore the title line after every command has run.  Some people
make the mistake of using it to set up a prompt, but there are enough
ways of getting varying information into a fixed prompt string that you
shouldn't do that unless you have em(very) odd things in your prompt.
It's a big nuisance having to redefine tt(precmd) to alter your prompt
--- especially if you don't know it's there, since then your prompt
apparently magically returns to the same format when you change it.
There are some good reasons for using tt(precmd), too, but most of them
are fairly specialised.  For example, on one system I use it to check if
there is new input from a programme which is sending data to the shell
asynchronously, and if so printing it out onto the terminal.  This is
pretty much what happens with job control notification if you don't have
the tt(NOTIFY) option set.

The name tt(precmd) is a bit of a misnomer: tt(preprompt) would have
been better.  It usurps the name more logically applied to the function
actually called tt(preexec), which is run after you finished editing a
command line, but just before the line is executed.  tt(preexec) has one
additional feature: the line about to be executed is passed down as an
argument.  You can't alter what's going to be executed by editing the
parameter, however: that has been suggested as an upgrade, but it would
make it rather easy to get the shell into a state where you can't
execute any commands because tt(preexec) always messes them up.  It's
better, where possible, to write function front-ends to specific
commands you want to handle specially.  For example, here's my tt(ls)
function:
verb(  local ls
  if [[ -n $LS_COLORS ]]; then
    ls=(ls --color=auto)
  else
    ls=(ls -F)
  fi
  command $ls $*)
This handles GNU and non-GNU versions of ls.  If tt($LS_COLORS) is set, it
assumes we are using GNU ls, and hence colouring (or colorizing, in
geekspeak) is available.  Otherwise, it uses the standard option tt(-F) to
show directories and links with a special symbol.  Then it uses tt(command)
to run the real tt(ls) --- this is a key thing to remember any time you use
a function front-end to a command.  I could have done this another way:
test in my initialisation files which version of tt(ls) I was using, then
alias tt(ls) to one of the two forms.  But I didn't.

Apart from the trap functions, there is one remaining special function.
It is tt(periodic), which is executed before a prompt, like tt(precmd),
but only every now and then, in fact every tt($PERIOD) seconds; it's up
to you to set tt($PERIOD) when you defined tt(periodic).  If tt($PERIOD)
isn't set, or is zero, nothing happens.  Don't get tt($PERIOD) confused
with tt($SECONDS), which just counts up from 0 when the shell starts.

sect(Aliases)

Aliases are much simpler than functions.  In the C shell and its
derivatives, there are no functions, so aliases take their place and can
have arguments, which involve expressions rather like those which extract
elements of previous history lines with `tt(!)'.  Zsh's aliases, like
ksh's, don't take arguments; you have to use functions for that.  However,
there are things aliases can do which functions can't, so sometimes you end
up using both, for example
verb(  zfget() {
    # function to retrieve a file by FTP,
    # using globbing on the remote host
  }
  alias zfget='noglob zfget')
The function here does the hard work; this is a function from the zftp
function suite, supplied with the shell, which retrieves a file or set of
files from another machine.  The function allows patterns, so you can
retrieve an entire directory with `tt(zfget *)'.  However, you need to
avoid the `tt(*)' being expanded into the set of files in the current
directory on the machine you're logged into; this is where the alias comes
in, supplying the `tt(noglob)' in front of the function.  There's no way of
doing this with the function alone; by the time the function is called, the
`tt(*)' would already have been expanded.  Of course you could quote it,
but that's what we're trying to avoid.  This is a common reason for using
the alias/function combination.

Remember to include the `tt(=)' in alias definition, necessary in zsh,
unlike csh and friends.  If you do:
verb(  alias zfget noglob zfget)
they are treated as a list of aliases.  Since none has the `tt(=)' and a
definition, the shell thinks you want to list the definitions of the listed
words; I get the output
verb(  zfget='noglob zfget'
  zfget='noglob zfget')
since tt(zfget) was aliased as before, but tt(noglob) wasn't aliased and
was skipped, although the failed alias lookup caused status 1 to be
returned.  Remember that the tt(alias) command takes as many arguments as
you like; any with `tt(=)' is a definition, any without is a request to
print the current definition.

Aliases can in fact be allowed to expand to almost anything the shell
understands, not just sets of words.  That's because the text retrieved
from the alias is put back into the input, and reread more or less as if
you'd typed it.  That means you can get away with strange combinations like
verb(  alias tripe="echo foo | sed 's/foo/bar/' |"
  tripe cat)
which is interpreted exactly the same way as
verb(  echo foo | sed 's/foo/bar/' | cat)
where the word `tt(foo)' is sent to the stream editor, which alters it to
`tt(bar)' (`tt(s/old/new/)' is tt(sed)'s syntax for a substitution), and
passes it on to `tt(cat)', which simply dumps the output.  It's useless, of
course, but it does show what can lurk behind an apparently simple command
if it happens to be an alias.  It is usually not a good idea to do this,
due to the potential confusion.

As the manual entry explains, you can prevent an alias from being expanded
by quoting it.  This isn't like quoting any other expansion, though;
there's no particular important character which has to be interpreted
literally to stop the expansion.  The point is that because aliases are
expanded early on in processing of the command line, looking up an alias is
done on a string without quotes removed.  So if you have an alias
`tt(drivel)', none of the strings `tt(\drivel)', `tt('d'rivel)', or
`tt(drivel"")' will be expanded as the alias:  they all would have the same
effect as proper commands, after the quotes are removed, but as aliases
they appear different.  The manual entry also notes that you can actually
make aliases for any of these special forms, e.g. `tt(alias '\drivel'=...)'
(note the quotes, since you need the backslash to be passed down to the
alias command).  You would need a pretty good reason to do so.

Although my `tt(tripe)' example was silly, you know from the existence of
`precommand modifiers' that it's sometimes useful to have a special command
which precedes a command line, like tt(noglob) or the non-shell command
tt(nice).  Since they have commands following, you would probably expect
aliases to be expanded there, too.  But this doesn't work:
verb(  % alias foo='echo an alias for foo'
  % noglob foo
  zsh: command not found: foo)
because the tt(foo) wasn't in command position.  The way round this is to
use a special feature:  aliases whose definitions end in a space force the
next word along to be looked up as a possible alias, too:
verb(  % alias noglob='noglob '
  % noglob foo
  an alias for foo)
which is useful for any command which can take a command line after it.
This also shows another feature of aliases:  unlike functions, they
remember that you have already called an alias of a particular name, and
don't look it up again.  So the `tt(noglob)' which comes from expanding the
alias is not treated as an alias, but as the ordinary precommand modifier.

You may be a little mystified about this difference.  A simple answer is
that it's useful that way.  It's sometimes useful for functions to call
themselves; for example if you are handling a directory hierarchy in one go
you might get a function to examine a directory, do something for every
ordinary file, and for every directory file call itself with the new
directory name tacked on.  Aliases are too simple for this to be a useful
feature.  Another answer is that it's particularly easy to mark aliases as
being `in use' while they are being expanded, because it happens while the
strings inside them are being examined, before any commands are called,
where things start to get complicated.

Lastly, there are `global aliases'.  If aliases can get you into a lot of
trouble, global aliases can get you into a lot of a lot of trouble.  They
are defined with the option tt(-g) and are expanded not just in command
position, but anywhere on the command line.
verb(  alias -g L='| less'
  echo foo L)
This turns into `tt(echo foo | less)'.  It's a neat trick if you don't mind
your command lines having only a minimal amount to do with what is actually
executed.

I already pointed out that alias lookups are done so early that aliases are
expanded when you define functions:
verb(  % alias hello='echo I have been expanded'
  % fn() {
  function>  hello
  function> }
  % which fn
  fn () {
          echo I have been expanded
  })
You can't stop this when typing in functions directly, except by
quoting part of the name you type.  When autoloading, the tt(-U) option is
available, and recommended for use with any non-trivial function.

A brief word about that `tt(function>)' which appears to prompt you while
you are editing a function; I mentioned this in the previous chapter but
here I want to be clearer about what's going on.  While you are being
prompted like that, the shell is not actually executing the commands you
are typing in.  Only when it is satisfied that it has a complete set of
commands will it go away and execute them (in this case, defining the
function).  That means that it won't always spot errors until right at the
end.  Luckily, zsh has multi-line editing, so if you got it wrong you
should just be able to hit up-arrow and edit what you typed; hitting return
will execute the whole thing in one go.  If you have redefined tt($PS2) (or
tt($PROMPT2)), or you have an old version of the shell, you may not see the
full prompt, but you will usually see something ending in `tt(>)' which
means the same.

sect(Command summary)

As a reminder, the shell looks up commands in this order:

startit()
  it() aliases, which will immediately be interpreted again as texts for
  commands, possible even other aliases; they can be deleted with
  `tt(unalias)',

  it() reserved words, those special to the shell which often need to be
  interpreted differently from ordinary commands due to the syntax, although
  they can be disabled if you really need to,

  it() functions; these can also be disabled, although it's usually easier
  to `tt(unfunction)' them,

  it() builtin commands, which can be disabled, or called as a builtin by
  putting `tt(builtin)' in front,

  it() external commands, which can be called as such, even if the name
  clashes with one of the above types, by putting `tt(command)' in front.
endit()

sect(Expansions and quotes)

As I keep advertising, there will be a whole chapter dedicated to the
subject of shell expansions and what to do with them.  However, it's a
rather basic subject, which definitely comes under the heading of basic
shell syntax, so I shall here list all the forms of expansion.  As given in
the manual, there are five stages.

subsect(History expansion)

This is the earliest, and is only done on an interactive command line, and
only if you have not set tt(NO_BANG_HIST).  It was described in the section
`em(The history mechanism; types of history)' in the previous chapter.
It is almost independent of the shell's processing of the command line; it
takes place as the command line is read in, not when the commands are
interpreted.  However, in zsh it is done late enough that the `tt(!)'s can
be quoted by putting them in single quotes:
verb(  echo 'Hello!!')
doesn't insert the previous line at that point, but
verb(  echo "Hello!!")
does.  You can always quote active `tt(!)'s with a backslash, so
verb(  echo "Hello\!\!")
works, with or without the double quotes.  Amusingly, since single quotes
aren't special in double quotes, if you set the tt(HIST_VERIFY) option,
which puts the expanded history line back on the command line for possible
further editing, and try the first two of the three possibilities above in
order, then keep hitting return, you will find ever increasing command
lines:
verb(  % echo 'Hello!!'
  Hello!!
  % echo "Hello!!"
  % echo "Helloecho 'Hello!!'"
  % echo "Helloecho 'Helloecho 'Hello!!''"
  % echo "Helloecho 'Helloecho 'Helloecho 'Hello!!'''")
and if you understand why, you have a good grasp of how quotes work.

There's another way of quoting exclamation marks in a line:  put a `tt(!")'
in it.  It can appear anywhere (as long as it's not in single quotes) and
will be removed from the line, but it has the effect of disabling any
subsequent exclamation marks till the end of the line.  This is the only
time quote marks which are significant to the shell (i.e. are not
themselves quoted) don't have to occur in a matching pair.

Note that as exclamation marks aren't active in any text read
non-interactively --- and this includes autoloaded functions and sourced
files, such as startup files, read inside interactive shells --- it is an
error to quote any `tt(!)'s in double quotes in files.  This will simply
pass on the backslashes to the next level of parsing.  Other forms of
quoting are all right: `tt(\!)', because any character quoted with a
backslash is treated as itself, and tt('!') because single quotes can quote
anything anyway.

subsect(Alias expansion)

As discussed above, alias expansion also goes on as the command line is
read, so is to a certain extent similar to history expansion.  However,
while a history expansion may produce an alias for expansion, `tt(!)'s in
the text resulting from alias expansions are normal characters, so it can
be thought of as a later phase (and indeed it's implemented that way).

subsect(Process, parameter, command, arithmetic and brace expansion)

There are a whole group of expansions which are done together, just by
looking at the line constructed from the input after history and alias
expansion and reading it from left to right, picking up any active
expansions as the line is examined.  Whenever a complete piece of
expandable text is found, it is expanded; the text is not re-examined,
except in the case of brace expansion, so none of these types of expansion
is performed on any resulting text.  Whether later forms of expansion ---
in other words, filename generation and filename expansion are performed
--- is another matter, depending largely on the tt(GLOB_SUBST) option as
discussed in the previous chapter.  Here's a brief summary of the different
types.

nsubsubsect(Process substitution)

There are three forms that result in
a command line argument which refers to a file from or to which
input or output is taken:  `tt(<)LPAR()var(process)RPAR()'
runs the process which is expected to generate output which can be used
as input by a command; `tt(>)LPAR()var(process)RPAR()' runs the
process which will take input to it; and
`tt(=)LPAR()var(process)RPAR()' acts like the first one, but it is
guaranteed that the file is a plain file.

This probably sounds like gobbledygook.  Here are some simple examples.
verb(  cat < <(echo This is output))
(There are people in the world with nothing better to do than compile lists
of dummy uses of the `tt(cat)' command, as in that example, and pour scorn
on them, but I'll just have to brave it out.)  What happens is that the
command `tt(echo This is output)' is run, with the obvious result.  That
output is em(not) put straight into the command line, as it would be with
command substitution, to be described shortly.  Instead, the command line
is given a filename which, when read, gets that output.  So it's more like:
verb(  echo This is output >tmpfile
  cat < tmpfile
  rm tmpfile)
(note that the temporary file is cleaned up automatically), except that
it's more compact.  In this example I could have missed out the remaining
`tt(<)', since tt(cat) does the right thing with a filename, but I put it
there to emphasise the fact that if you want to redirect input from the
process substitution you need an em(extra) `tt(<)', over and above the one
in the substitution syntax.

Here's an example for the corresponding output substitution:
verb(  echo This is output > \ 
  >(sed 's/output/rubbish/' >outfile))
which is a perfectly foul example, but works essentially like:
verb(  echo This is output >tmpfile
  sed 's/output/rubbish/' <tmpfile >outfile)
There's an obvious relationship to pipes here, and in fact this example
could be better written,
verb(  echo This is output | sed 's/output/rubbish/' >outfile)
A good example of an occasion where the output process substitution can't
be replaced by a pipe is when it's on the error output, and standard output
is being piped:
verb(  ./myscript 2> >(grep -v idiot >error.log) |
      process-output >output.log)
a little abstract, but here the main point of the script `myscript' is to
produce some output which undergoes further processing on the right-hand
side of the pipe.  However, we want to process the error output here, by
filtering out occurrences of lines which use the word `idiot', before
dumping those errors into a file tt(error.log).  So we get an effect
similar to having two pipelines at once, one for output and one for error.
Note again the em(two) `tt(>)' signs present next to one another to get
that effect.

Finally, the `tt(=)LPAR()var(process)RPAR()' form.  Why do we need this
as well as the one with `tt(<)'?  To understand that, you need to know a
little of how zsh tries to implement the latter type efficiently.  Most
modern UNIX-like systems have `named pipes', which are essentially files
that behave like the `tt(|)' on the command line:  one process writes to
the file, another reads from it, and the effect is essentially that data
goes straight through.  If your system has them, you will usually find the
following demonstration works:
verb(  % mknod tmpfile p
  % echo This is output >tmpfile &
  [2] 1507
  % read line <tmpfile
  %
  [2]  + 1507 done       echo This is output >> tmpfile
  % print -- $line
  This is output
  %)
The syntax to create a named pipe is that rather strange `tt(mknod)'
command, with `tt(p)' for pipe.  We stick this
in the background, because it won't do anything yet:  you can't write to
the pipe when there's no-one to read it (a fundamental rule of pipes which
isn't em(quite) as obvious as it may seem, since it em(is) possible for
data to lurk in the pipe, buffered, before the process reading from it
extracts it), so we put that in the background to wait for action.  This
comes in the next line, where we read from the pipe:  that allows the
tt(echo) to complete and exit.  Then we print out the line we've read.

The problem with pipes is that they are just temporary storage spaces for
data on the way through.  In particular, you can't go back to the beginning
(in C-speak, `you can't seek backwards on a pipe') and re-read what was
there.  Sometimes this doesn't matter, but some commands, such as editors,
need that facility.  As the `tt(<)' process substitution is implemented with
named pipes (well, maybe), there is also the `tt(=)' form, which produces a
real, live temporary file, probably in the `tt(/tmp)' directory, containing
the output from the file, and then puts the name of that file on the
command line.  The manual notes, unusually helpfully, that this is useful
with the `tt(diff)' command for comparing the output of two processes:
verb(  diff =(./myscript1) =(./myscript2))
where, presumably, the two scripts produce similar, but not identical,
output which you want to compare.

I said `well, maybe' in that paragraph because there's another way zsh can
do `tt(<)' process substitutions.  Many modern systems allow you to access
a file with a name like `tt(/dev/fd/0)' which corresponds to file
descriptor 0, in this case standard input: to anticipate the section on
redirection, a `file descriptor' is a number assigned to a particular input
or output stream.  This method allows you to access it as a file; and if
this facility is available, zsh will use it to pass the name of the file in
process substitution instead of using a named pipe, since in this case it
doesn't have to create a temporary file; the system does everything.  Now,
if you are really on the ball, you will realise that this doesn't get
around the problem of pipes --- where is data on this file descriptor going
to come from?  The answer is that it will either have to come from a real
temporary file --- which is pointless, because that's what we wanted to
avoid --- or from a pipe opened from some process --- which is equivalent
to the named pipe method, except with just a file descriptor instead of a
name.  So even if zsh does it this way, you still need the `tt(=)' form for
programmes which need to go backwards in what they're reading.

nsubsubsect(Parameter substitution)

You've seen enough of this already.  This comes from a `tt($)' followed
either by something in braces, or by alphanumeric characters forming the
name of the parameter: `tt($foo)' or `tt(${foo})', where the second form
protects the expansion from any  other strings at the ends and also allows
a veritable host of extra things to appear inside the braces to modify the
substitution.  More detail will be held over to till
lref(chapter)(subst); there's a lot of it.

nsubsubsect(Command substitution)

This has two forms, tt($)LPAR()var(process)RPAR() and
tt(`)var(process)tt(`).  They function identically; the first form has two
advantages: substitutions can be nested, since the end character is
different from the start character, and (because it uses a `tt($)') it
reminds you that, like parameter substitutions, command substitutions can
take place inside double-quoted strings.  In that case, like most other
things in quotes, the result will be a single word; otherwise, the result
is split into words on any field separators you have defined, usually
whitespace or the null character.  I'll use the tt(args) function again:
verb(  % args() { print $# $*; }
  % args $(echo two words)
  2 two words
  % args "$(echo one word)"
  1 one word)
The first form will split on newlines, not just spaces, so an equivalent is
verb(  % args $(echo two; echo words)
  2 two words)
Thus entire screens of text will be flattened out into a single line of
single-word command arguments.  By contrast, with the double quotes no
processing is done whatsoever; the entire output is put verbatim into one
command argument, with newlines intact.  This means that the quite common
case of wanting a single complete line from a file per command argument has
to be handled by trickery; zsh has such trickery, but that's the stuff of
lref(chapter)(subst).

Note the difference from process substitution:  no intermediate file name
is involved, the output itself goes straight onto the command line.  This
form of substitution is considerably more common, and, unlike the other, is
available in all UNIX shells, though not in all shells with the more modern
form `tt($)LPAR()tt(...)RPAR()'.

The rule that the command line is evaluated only once, left to right, is
adhered to here, but it's a little more complicated in this case since the
expression being substituted is scanned em(as a complete command line), so
can include anything a command usually can, with all the rules of quoting
and expansion being applied.  So if you get confused about what a command
substitution is actually up to, you should extract the commands from it and
think of them as a command line in their own right.  When you've worked out
what that's doing, decide what it's output will be, and that's the result
of the substitution.  You can ignore any error output; that isn't captured,
so will go straight to the terminal.  If you want to ignore it, use the
standard trick (see below) `tt(2>/dev/null)' em(inside) the command
substitution --- not on the main command line, where it won't work because
substitutions are performed before redirection of the main command line,
and in any case that will have the obvious side effect of changing the
error output from the command line itself.

The only real catch with command substitution is that, as it is run as a
separate process --- even if it only involves shell builtins --- no effects
other than the output will percolate back to the main shell:
verb(  % print $(bar=value; print bar is $bar)
  bar is value
  % print bar is $bar
  bar is)
There is maybe room for a form of substitution that runs inside the shell,
instead; however, with modern computers the overhead in starting the extra
process is pretty small --- and in any case we seem to have run out of
new forms of syntax.

Once you know and are comfortable with command substitution, you will
probably start using it all the time, so there is one good habit to get
into straight away.  A particularly common use is simply to put the
contents of a file onto the command line.
verb(  # Don't do this, do the other.
  process_cmd `cat file_arguments`)
But there's a shortcut.
verb(  # Do do this, don't do the other
  process_cmd $(<file_arguments))
It's not only less writing, it's more efficient:  zsh spots the special
syntax, with the tt(<) immediately inside the parentheses, reads the file
directly without bothering to start `tt(cat)', and inserts its contents:
no external process is involved.  You shouldn't confuse this with `null
redirections' as described below:  the syntax is awfully similar,
unfortunately, but the feature shown here is not dependent on that other
feature being enabled or set up in a particular way.  In fact, this feature
works in ksh, which doesn't have zsh's null redirections.

You can quote the file-reading form too, of course: in that case, the
contents of the file `tt(cmd_arguments)' would be passed as just one
argument, with newlines and spaces intact.

Sometimes, the rule about splitting the result of a command substitution
can get you into trouble:
verb(  % typeset foo=`echo words words`
  % print $foo
  words)
You probably expected the command substitution em(not) to be split
here. but it was, and the shell executed typeset with the arguments
`tt(foo=words)' and `words'.  That's because in zsh arguments to
tt(typeset) are treated pretty much normally, except for some jiggery
pokery with tildes described below.  Other shells do this differently, and
zsh (from 4.0.2 and 4.1.1) provides a compatibility option,
tt(KSH_TYPESET).  In earlier versions you need to use
quotes:
verb(  % typeset foo="`echo words words`"
  % print $foo
  words words)

A really rather technical afterword: using `tt($(cat file_arguments))', you
might have counted two extra processes to be started, one being the usual
one for a command substitution, and another the `tt(cat)' process, since
that's an external command itself.  That would indeed be the obvious way of
doing it, but in fact zsh has an optimisation in cases like this: if it
knows the shell is about to exit --- in this case, the forked process which
is just interpreting the command line for the substitution --- it will not
bother to start a new process for the last command, and here just replaces
itself with the tt(cat).  So actually there's only one extra process here.
Obviously, an interactive shell is never replaced in this way, since
clairvoyance is not yet a feature of the shell.

nsubsubsect(Arithmetic substitution)

Arithmetic substitution is easy to explain:  everything I told you about
the tt((( ... ))) command under numerical parameters, above, applies to
arithmetic substitution.  You simply bang a `tt($)' in front, and it becomes
an expansion.
verb(  % print $(( 32 + 2 * 5 ))
  42)
You can perform everything inside arithmetic substitution that you
can inside the builtin, including assignments; the only difference is that
the status is not set, instead the value is put directly onto the command
line in place of the original expression.  As in C, the value of an
assignment is the value being assigned, `tt($(( param = 3 + 2)))'
substitutes the value 5 as well as assigning it to tt($param).

By the way, there's an extra level of substitution involved in all
arithmetic expansions, since scalar parameters are subject to arithmetic
expansion when they're read in.  This is simple if they only contain
numbers, but less obvious if they contain complete expressions:
verb(  % foo=3+5
  % print $(( foo + 2))
  10)
The foo was evaluated into 8 before it was substituted in.  Note this means
there were two evaluations:  this doesn't work:
verb(  % foo=3+
  % print $(( foo 2 ))
  zsh: bad math expression: operand expected at `')
--- the complaint here is about the missing operand after the `tt(+)' in
the tt($foo).  However the following em(does) work:
verb(  % foo=3+
  % print $(( $foo 2 ))
  5)
That's because the scalar tt($foo) is turned into tt(3+) first.  This is
more logical than you might think:  with the rule about left to right
evaluation, the tt($foo) is picked up inside the tt($((...))) and expanded
as an ordinary parameter substitution while the argument of tt($((...)))
is being scanned.  Then the complete argument `tt(3+ 2)' is expanded as an
arithmetical expression.  (Unfortunately, zsh isn't always this logical;
there could easily be cases where we haven't thought it through --- you
should feel free to bring these to our attention.)

There's an older form with single square brackets instead of double
parentheses; there is now no reason to use it, as it's non-standard, but
you may sometimes still meet it.

nsubsubsect(Brace expansion)

Brace expansion is a feature acquired from the C shell and it's relatives,
although some versions of ksh have it, as it's a compile time option
there.  It's a useful way of saving you from typing the same thing twice on
a single command line:
verb(  % print -l {foo,bar}' is used far too often in examples'
  foo is used far too often in examples
  bar is used far too often in examples)
`tt(print)' is given two arguments which it is told to print out one per
line.  The text in quotes is common to both, but one has `tt(foo)' in
front, while the other has `tt(bar)' in front.  The brace expression can
equally be in the middle of an argument:  for example, a common use of this
among programmers is for similarly named source files:
verb(  % print zle_{tricky,vi,word}.c
  zle_tricky.c zle_vi.c zle_word.c)
As you see, you're not limited to two; you can have any number.  You can
quote a comma if you need a real one:
verb(  % print -l \`{\,,.}\'' is a punctuation character'
  `,' is a punctuation character
  `.' is a punctuation character)
The quotes needed quoting with a backslash to get them into the output.
The second comma is the active one for the braces.

You can nest braces.  Once again, this is done left to right.  In
verb(  print {now,th{en,ere{,abouts}}})
the first argument of the outer brace is `tt(now)', and the second is
`tt(th{en,ere{,abouts}})'.  This brace expands to `tt(then)' and then the
expansion of `tt(there{,abouts})', which is `tt(there thereabouts)' ---
there's nothing to stop you having an empty argument.  Putting this all
together, we have
verb(  print now then there thereabouts)

There's more to know about brace expansion, which will appear in
lref(chapter)(subst) on clever expansions.

subsect(Filename Expansion)

It's a shame the names `filename expansion' and `filename generation' sound
so similar, but most people just refer to `tt(~) and tt(=) expansion' and
`globbing' respectively, which is all that is meant by the two.  The first
is by far the simpler.  The rule is:  unquoted `tt(~)'s at the beginning of
words perform expansion of named directories, which may be your home
directory:
verb(  % print ~
  /home/pws)
some user's home directory:
verb(  % print ~root
  /root)
(that may turn up `tt(/)' on your system), a directory named directly by you:
verb(  % t=/tmp
  % print ~t
  /tmp)
a directory you've recently visited:
verb(  % pwd
  /home/pws/zsh/projects/zshguide
  % print ~+
  /home/pws/zsh/projects/zshguide
  % cd /tmp
  % print ~-
  /home/pws/zsh/projects/zshguide)
or a directory in your directory stack:
verb(  % pushd /tmp
  % pushd ~
  % pushd /var/tmp
  % print ~2
  /tmp)
These forms were discussed above.  There are various extra rules.  You can
add a `tt(/)' after any of them, and the expansions still take place, so
you can use them to specify just the first part of a longer expression (as
you almost certainly have done with a simple `tt(~)').  If you quote the
`tt(~)' in any of the ways quoting normally takes place, the expansion
doesn't happen.

A tt(~) in the middle of the word means something completely different, if
you have the tt(EXTENDED_GLOB) option set; if you don't, it doesn't mean
anything.  There are a few exceptions here; assignments are a fairly
natural one:
verb(  % foo=~pws
  % print $foo
  /home/pws)
(note that the `tt(~pws)', being unquoted, was expanded straight away at
the assignment, not at the print statement).  But the following works too:
verb(  % PATH=$PATH:~pws/bin)
because colons are special in assignments.  Note that this happens even if
the variable isn't a colon-separated path; the shell doesn't know what use
you're going to make of all the different variables.

The companion of `tt(~)' is `tt(=)', which again has to occur at the start
of a word or assignment to be special.  The remainder of the word (here the
em(entire) remainder, because directory paths aren't useful) is taken as
the name of an external command, and the word is expanded to the complete
path to that command, using tt($PATH) just as if the command were to be
executed:
verb(  % print =ls
  /bin/ls)
and, slightly confusingly,
verb(  % foo==ls
  % print $foo
  /bin/ls)
where the two `tt(=)'s have two different meanings.  This form is useful
in a number of cases.  For example, you might want to look at or edit a
script which you know is in your path; the form
verb(  % vi =scriptname)
is more convenient than the more traditional
verb(  % vi `whence -p ls`)
where I put the `tt(-p)' in to force tt(whence) to follow the path,
ignoring builtins, functions, etc.  This brings us to another use for
`tt(=)' expansion,
verb(  % =ls)
is a neat and extremely short way of referring to an external command when
tt(ls) is usually a function.  It has some of the same effect
as `tt(command ls)', but is easier to type.

In versions up to and including tt(4.0), this syntax will also expand
aliases, so you need to be a bit careful if you really want a path to an
external command:
verb(  % alias foo='ls -F'
  % print =foo
  ls -F)
(Path expansion is done in preference, so you are safe if you use
tt(ls), unless your tt($PATH) is strange.)  Putting `tt(=foo)' at the
start of the command line doesn't work, and the reason why bears
examination:  tt(=)-expansion occurs quite late on, after ordinary alias
expansion and word splitting, so that the result is the single word
`tt(ls -F)', where the space is part of the word, which probably doesn't
mean anything (and if it does, don't lend me your computer when I need
something done in a hurry).  It's probably already obvious that alias
expansion here is more trouble than it's worth.  A less-than-exhaustive
search failed to find anyone who liked this feature, and it has been
removed from the shell from 4.1, so that `tt(=)'-expansion now only
expands paths to external commands.

If you don't like tt(=)-expansion, you can turn it off by setting the
option tt(NO_EQUALS).  One catch, which might make you want to do that, is
that the commands tt(mmv), tt(mcp) and tt(mln), which are a commonly used
though non-standard piece of free software, use `tt(=)' followed by a
number to replace a pattern, for example
verb(  mmv '*.c' '=1.old.c')
renames all files ending with tt(.c) to end with tt(.old.c).  If you were
not alert, you might forget to quote the second word.  Otherwise, however,
tt(=)' isn't very common at the start of a word, so you're probably fairly
safe.  For a way to do that with zsh patterns, see the discussion of
the function tt(zmv) below (the answer is `tt(zmv '(*).c' '$1.old.c')').

Note that zsh is smart enough to complete the names of commands after an
`tt(=)' of the expandable sort when you hit TAB.

subsect(Filename Generation)

Filename generation is exactly the same as `globbing':  the expanding of
any unquoted wildcards to match files.  This is only done in one directory
at a time.  So for example
verb(  print *.c)
won't match files in a subdirectory ending in `tt(.c)'.  However, it em(is)
done on all parts of a path, so
verb(  print */*.c)
will match all `tt(.c)' files in all immediate subdirectories of the
current directory.  Furthermore, zsh has an extension --- one of its most
commonly used special features --- to match files in any subdirectory at
any depth, including the current directory: use two `tt(*)'s as part of the
path:
verb(  print **/*.c)
will match `tt(prog.c)', `tt(version1/prog.c)',
`tt(version2/test/prog.c)', `tt(oldversion/working/saved/prog.c)', and
so on.  I will talk about filename generation and other uses of zsh's
extremely powerful patterns at much greater length in
lref(chapter)(subst).  My main thrust here is to fit it into other forms
of expansion; the main thing to remember is that it comes last, after
everything has already been done.

So although you would certainly expect this to work,
verb(  print ~/*)
generating all files in your home directory, you now know why:  it is first
expanded to `tt(/home/pws/*)' (or wherever), then the shell scans down the
path until it finds a pattern, and looks in the directory it has reached
(tt(/home/pws)) for matching files.  Furthermore,
verb(  foo=~/
  print $foo*)
works.  However, as I explained in the last chapter, you need to be careful
with
verb(  foo=*
  print ~/$foo)
This just prints `tt(/home/pws/*)'.  To get the `tt(*)' from the parameter
to be a wildcard, you need to tell the shell explicitly that's what you
want:
verb(  foo=*
  print ~/${~foo})
As also noted, other shells do expand the tt(*) as a wildcard anyway.  The
zsh attitude here, as with word splitting, is that parameters should do
exactly what they're told rather than waltz off generating extra words or
expansions.

Be even more careful with arrays:
verb(  foo=(*))
will expand the tt(*) immediately, in the current directory --- the
elements of the array assignment are expanded exactly like a normal command
line glob.  This is often very useful, but note the difference from scalar
assignments, which do other forms of expansion, but not globbing.

I'll mention a few possible traps for the unwary, which might confuse you
until you are a zsh globbing guru.  Firstly, parentheses actually have two
uses.  Consider:
verb(  print (foo|bar)(.))
The first set of parentheses means `match either tt(foo) or tt(bar)'.  If
you've used tt(egrep), you will probably be familiar with this.  The
second, however, simply means `match only regular files'.  The `tt((.))' is
called a `globbing qualifier', because it limits the scope of any matches so
far found.  For example, if either or both of tt(foo) and tt(bar) were
found, but were directories, they would not now be matched.  There are many
other possibilities for globbing qualifiers.  For now, the easiest way to
tell if something at the end is em(not) a globbing qualifier is if it
contains a `tt(|)'.

The second point is about forms like this:
verb(  print file-<1-10>.dat)
The `tt(<)' and `tt(>)' smell of redirection, as described next, but
actually the form `tt(<)', optional start number, `tt(-)', optional finish
number, `tt(>)' means match any positive integer in the range between the
two numbers, inclusive; if either is omitted, there is no limit on that
end, hence the cryptic but common `tt(<->)' to match any positive integer
--- in other words, any group of decimal digits (bases other than ten are
not handled by this notation).  Older versions of the shell allowed the
form `tt(<>)' as a shorthand to match any number, but the overlap with
redirection was too great, as you'll see, so this doesn't work any more.

Another two cryptic symbols are the two that do negation.  These only work
with the option `tt(EXTENDED_GLOB)' set:  this is necessary to get the most
out of zsh's patterns, but it can be a trap for the unwary by turning
otherwise innocuous characters into patterns:
verb(  print ^foo)
This means any file in the current directory em(except) the file tt(foo).
One way of coming unstuck with `tt(^)' is something like
verb(  stty kill ^u)
where you would hope `tt(^u)' means control with `tt(u)', i.e. ASCII
character 21.  But it doesn't, if tt(EXTENDED_GLOB) is set:  it means `any
file in the current directory except one called `tt(u)' ', which is
definitely a different thing.  The other negation operator isn't usually so
fraught, but it can look confusing:
verb(  print *.c~f*)
is a pattern of two halves; the shell tries to match `tt(*.c)', but rejects
any matches which also match `tt(f*)'.  Luckily, a `tt(~)' right at the
end isn't special, so
verb( rm *.c~)
removes all files ending in `tt(.c~)' --- it wouldn't be very nice if it
matched all files ending in `tt(.c)' and treated the final `tt(~)' as an
instruction not to reject any, so it doesn't.  The most likely case I can
think of where you might have problems is with Emacs' numeric backup files,
which can have a `tt(~)' in the middle which you should quote.  There is no
confusion with the directory use of `tt(~)', however:  that only occurs at
the beginning of a word, and this use only occurs in the middle.

The final oddments that don't fit into normal shell globbing are forms with
`tt(#)'.  These also require that tt(EXTENDED_GLOB) be set.  In the
simplest use, a `tt(#)' after a pattern says `match this zero or more
times'.  So `tt((foo|bar)#.c)' matches tt(foo.c), tt(bar.c), tt(foofoo.c),
tt(barbar.c), tt(foobarfoo.c), ...  With an extra tt(#), the pattern before
(or single character, if it has no special meaning) must match at least
once.  The other use of `tt(#)' is in a facility called `globbing flags',
which look like `tt((#X))' where `tt(X)' is some letter, possibly followed
by digits.  These turn on special features from that point in the pattern
and are one of the newest features of zsh patterns; they will receive much
more space in lref(chapter)(subst).

sect(Redirection: greater-thans and less-thans)

Redirection means retrieving input from some other file than the usual one,
or sending output to some other file than the usual one.  The simplest
examples of these are `tt(<)' and `tt(>)', respectively.
verb(  % echo 'This is an announcement' >tempfile
  % cat <tempfile >newfile
  % cat newfile
  This is an announcement)
Here, tt(echo) sends its output to the file tt(tempfile); tt(cat) took its
input from that file and sent its output --- the same as its input --- to
the file tt(newfile); the second tt(cat) takes its input from tt(newfile)
and, since its output wasn't redirected, it appeared on the terminal.

The other basic form of redirection is a pipe, using `tt(|)'.  Some people
loosely refer to all redirections as pipes, but that's rather confusing.
The input and output of a pipe are em(both) programmes, unlike the case
above where one end was a file.  You've seen lots of examples already:
verb(  echo foo | sed 's/foo/bar/')
Here, tt(echo) sends its output to the programme tt(sed), which substitutes
foo by bar, and sends its own output to standard output.  You can chain
together as many pipes as you like; once you've grasped the basic behaviour
of a single pipe, it should be obvious how that works:
verb(  echo foo is a word | 
    sed 's/foo/bar/' | 
    sed 's/a word/an unword/')
runs another tt(sed) on the output of the first one.  (You can actually
type it like that, by the way; the shell knows a pipe symbol can't be at
the end of a command.)  In fact, a single tt(sed) will suffice:
verb(  echo foo is a word |
    sed -e 's/foo/bar/' -e 's/a word/an unword/')
has the same effect in this case.

Obviously, all three forms of redirection only work if the programme in
question expects input from standard input, and sends output to standard
output.  You can't do:
verb(  echo 'edit me' | vi)
to edit input, since tt(vi) doesn't use the input sent to it; it always
deals with files.  Most simple UNIX commands can be made to deal with
standard input and output, however.  This is a big difference from other
operating systems, where getting programmes to talk to each other in an
automated fashion can be a major headache.

subsect(Clobber)

The word `clobber', as in the option tt(NO_CLOBBER) which I mentioned in
the previous chapter, may be unfamiliar to people who don't use English as
their first language.  Its basic meaning is `hit' or `defeat' or
`destroy', as in `Itchy and Scratchy clobbered each other with mallets'.
If you do:
verb(  % echo first go >file
  % echo second go >file)
then tt(file) will contain only the words `second go'.  The first thing you
put into the file, `first go', has been clobbered.  Hence the
tt(NO_CLOBBER) option: if this is set, the shell will complain when you try
to overwrite the file.  You can use `tt(>|file)' or `tt(>! file)' to
override this.  You usually can't use `tt(>!file)' because history
expansion will try to expand `tt(!file)' before the shell parses the line;
hence the form with the vertical bar tends to be more useful.

subsect(File descriptors)

UNIX-like systems refer to different channels such as input, output and
error by `file descriptors', which are small integers.  Usually three are
special: 0, standard input; 1, standard output; and 2, standard error.
Bourne-like shells (but not csh-like shells) allow you to refer to a
particular file descriptor, instead of standard input or output, by putting
the integer immediately before the `tt(<)' or `tt(>)' (no space is
allowed).  What's more, if the `tt(<)' or `tt(>)' is followed immediately
by `tt(&)', a file descriptor can follow the redirection (the one
before is optional as usual).  A common use is:
verb(  % echo This message will go to standard error >&2)
The command sends its message to standard output, file descriptor 1.  As
usual, `tt(>)' redirects standard output.  This time, however, it is
redirected not to a file, but to file descriptor 2, which is standard
error.  Normally this is the same device as standard output, but it can be
redirected completely separately.  So:
verb(  % { echo A message
  cursh> echo An error >&2 } >file
  An error
  % cat file
  A message)
Apologies for the slightly unclear use of the continuation prompt
`tt(cursh>)': this guide goes into a lot of different formats, and some
are a bit finicky about long lines in preformatted text.  As pointed out
above, the `tt(>file)' here will redirect all output from the stuff in
braces, just as if it were a single command.  However, the `tt(>&2)'
inside redirects the output of the second tt(echo) to standard 
error.  Since this wasn't redirected, it goes straight to the terminal.

Note the form in braces in the previous example --- I'm going to use that
in a few more examples.  It simply sends something to standard output, and
something else to standard error; that's its only use.  Apart from that,
you can treat the bit in braces as a black box --- anything which can
produce both sorts of output.

Sometimes you want to redirect both at once.  The standard Bourne-like way
of doing this is:
verb(  % { echo A message
  cursh> echo An error >&2 } >file 2>&1)
The `tt(>file)' redirects standard output from the tt({)em(...)tt(}) to the
file; the following tt(2>&1) redirects standard error to wherever standard
output happens to be at that point, which is the same file.  This allows
you to copy two file descriptors to the same place.  Note that the order is
important; if you swapped the two around, `tt(2>&1)' would copy standard
error to the initial destination of standard output, which is the terminal,
before it got around to redirecting standard output.

Zsh has a shorthand for this borrowed from csh-like shells:
verb(  % { echo A message
  cursh> echo An error >&2 } >&file)
is exactly equivalent to the form in the previous paragraph, copying
standard output and standard error to the same file.  There is obviously a
clash of syntax with the descriptor-copying mechanism, but if you don't
have files whose names are numbers you won't run into it.  Note that
csh-like shells don't have the descriptor-copying mechanism: the simple
`tt(>&)' and the same thing with pipes are the only uses of `tt(&)' for
redirections, and it's not possible there to refer to particular file
descriptors.

To copy standard error to a pipe, there are also two forms:
verb(  % { echo A message
  cursh> echo An error >&2 } 2>&1 | sed -e 's/A/I/'
  I message
  In error
  % { echo A message
  cursh> echo An error >&2 } |& sed -e 's/A/I/'
  I message
  In error)
In the first case, note that the pipe is opened before the other
redirection, so that `tt(2>&1)' copies standard error to the pipe, not the
original standard output; you couldn't put that after the pipe in any case,
since it would refer to the `tt(sed)' command's output.  The second way is
like csh; unfortunately, `tt(|&)' has a different meaning in ksh (start a
coprocess), so zsh is incompatible with ksh in this respect.

You can also close a file descriptor you don't need: the form `tt(2<&-)'
will close standard error for the command where it appears.

One thing not always appreciated about redirections is that they can occur
anywhere on the command line, not just at the end.
verb(  % >file echo foo
  % cat file
  foo)

subsect(Appending, here documents, here strings, read write)

There are various other forms which use multiple `tt(>)'s and `tt(<)'s.
First,
verb(  % echo foo >file
  % echo bar >>file
  % cat file
  foo
  bar)
The `tt(>)tt(>)' appends to the file instead of overwriting it.  Note, however,
that if you use this a lot you may find there are neater ways of doing the
same thing.  In this example,
verb(  % { echo foo
  cursh> echo bar } >file
  % cat file
  foo
  bar)
Here, `tt(cursh>)' is a prompt from the shell that it is waiting for you to
close the `tt({)' construct which executes a set of commands in the current
shell.  This construct can have a redirection applied to the entire
sequence of commands: `tt(>file)' after the closing brace therefore
redirects the output from both tt(echo)s.

In the case of input, doubling the sign has a totally different effect.
The word after the tt(<)tt(<) is not a file, but a string which will be
used to mark in the end of input.  Input is read until a line with only
this string is found:
verb(  % sed -e 's/foo/bar/' <<HERE
  heredoc> This line has foo in it.
  heredoc> There is another foo in this one.
  heredoc> HERE
  This line has a bar in it.
  There is another bar in this one.)
The shell prompts you with `tt(heredoc>)' to tell you it is reading a
`here document', which is how this feature is referred to.  When it finds
the final string, in this case `tt(HERE)', it passes everything you have
typed as input to the command as if it came from a file.  The command in
this case is the stream editor, which has been told to replace the first
`tt(foo)' on each line with a `tt(bar)'.  (Replacing things with a bar
is a familiar experience from the city centre of my home town, Newcastle
upon Tyne.)

So far, the features are standard in Bourne-like shells, but zsh has an
extension to here documents, sometimes referred to as `here strings'.
verb(  % sed -e 's/string/nonsense/' \ 
  > <<<'This string is the entire document.'
  This nonsense is the entire document.)
Note that `tt(>)' on the second line is a continuation prompt, not part
of the command line; it was just too long for the TeX version of this
document if I didn't split it.  This is a shorthand form of `here'
document if you just want to pass a single string to standard input.

The final form uses both symbols: `tt(<>file)' opens the file for
reading and writing --- but only on standard input.  In other words, a
programme can now both read from and write to standard input.  This
isn't used all that often, and when you do use it you should remember
that you need to open standard output explicitly to the same file:
verb(  % echo test >/tmp/redirtest
  % sed 's/e/Z/g' <>/tmp/redirtest 1>&0
  % cat /tmp/redirtest
  tZtst)
As standard input (the 0) was opened for writing, you can perform the
unusual trick of copying standard output (the 1) into it.  This is
generally not a particularly safe way of doing in-place editing,
however, though it seems to work fine with sed.  Note that in older
versions of zsh, `tt(<>)' was equivalent to `tt(<->)', which is a
pattern that matches any number; this was changed quite some time ago.

subsect(Clever tricks: exec and other file descriptors)

All Bourne-like shells have two other features.  First, the `command'
tt(exec), which I described above as being used to replace the shell with
the command you give after it, can be used with only redirections after
it.  These redirections then apply permanently to the shell itself, rather
than temporarily to a single command.  So
verb(  exec >file)
makes tt(file) the destination for standard output from that point on.  This
is most useful in scripts, where it's quite common to want to change the
destination of all output.

The second feature is that you can use file descriptors which haven't even
been opened yet, as long as they are single digits --- in other words, you
can use numbers 3 to 9 for your own purposes.  This can be combined with
the previous feature for some quite clever effects:
verb(  exec 3>&1               
  # 3 refers to stdout
  exec >file
  # stdout goes to `file', 3 untouched
      # random commands output to `file'
  exec 1>&3               
  # stdout is now back where it was
  exec 3>&-
  # file descriptor 3 closed to tidy up)
Here, file descriptor 3 has been used simply as a placeholder to remember
where standard output was while we temporarily divert it.  This is an
alternative to the `tt({)em(...)tt(} >file)' trick.  Note that you can put
more than one redirection on the tt(exec) line: `tt(exec 3>&1 >file)' also
works, as long as you keep the order the same.

subsect(Multios)

Multios allow you to do an implicit `tt(cat)' (concatenate files) on input
and `tt(tee)' (send the same data to different files) on output.  They
depend on the option tt(MULTIOS) being set, which it is by default.  I
described this in the last chapter in discussing whether or not you should
have the option set, so you can look at the examples there.

Here's one fact I didn't mention.  You use output multios like this:
verb(  command-generating-output >file1 >file2)
where the command's output is copied to both files.  This is done by a
process forked off by the shell:  it simply sits waiting for input, then
copies it to all the files in its list.  There's a problem in all versions
of the shell to date (currently 4.0.6):  this process is asynchronous, so
you can't rely on it having finished when the shell starts executing the
next command.  In other words, if you look at tt(file1) or tt(file2)
immediately after the command has finished, they may not yet contain all
the output because the forked process hasn't finished writing to it.

This is really a bug, but for the time being you will have to live with it
as it's quite complicated to fix in all cases.  Multios are most useful as
a shorthand in interactive use, like so much of zsh; in a script or
function it is safer to use tt(tee),
verb(  command-generating-output | tee file1 file2)
which does the same thing, but as tt(tee) is handled as a synchronous
process tt(file1) and tt(file2) are guaranteed to be complete when the
pipeline exits.

sect(Shell syntax: loops, (sub)shells and so on)

subsect(Logical command connectors)

I have been rather cavalier in using a couple of elements of syntax without
explaining them:
verb(  true  &&  print Previous command returned true
  false  ||  print Previous command returned false)
The relationship between `tt(&&)' and `tt(||)' and tests is fairly obvious,
but in this case they connect complete commands, not test arguments.
The `tt(&&)' executes the following command if the one before succeeded,
and the `tt(||)' executes the following command if the one before failed.
In other words, the first is equivalent to
verb(  if true; then
    print Previous command returned true
  fi)
but is more compact.

There is a perennial argument about whether to use these or not.  In the
comp.unix.shell newsgroup on Usenet, you see people arguing that the
`tt(&&)' syntax is unreadable, and only an idiot would use it, while
other people argue that the full `tt(if)' syntax is slower and clumsier,
and only an idiot would use that for a simple test; but Usenet is like
that, and both answers are a bit simplistic.  On the one hand, the
difference in speed between the two forms is minute, probably measurable
in microseconds rather than milliseconds on a modern computer; the
scheduling of the shell process running the script by the operating
system is likely to make more difference if these are embedded inside a
much longer script or function, as they will be.  And on the other hand,
the connection between `tt(&&)' and a logical `and' is so strong in the
minds of many programmers that to anyone with moderate shell experience
they are perfectly readable.  So it's up to you.  I find I use the
`tt(&&)' and `tt(||)' forms for a pair of simple commands, but use
`tt(if)' for anything more complicated.

I would certainly advise you to avoid chains like:
verb(  true || print foo && print bar || false)
If you try that, you will see `tt(bar)' but not `tt(foo)', which is not
what a C programmer might expect.  Using the usual rules of precedence, you
would parse it as: either tt(true) must be true; or both the tt(print)
statements must be true; or the false must be true.  However, the shell
parses it differently, using these rules:
startit()
  it() If you encounter an `tt(&&)',
  startit()
    it() if the command before it (really the complete pipeline)
    succeeded, execute the command immediately after, and execute what
    follows normally
    it() else if the command failed, skip the next command and any
    others until an `tt(||)' is encountered, or until the group of
    commands is ended by a newline, a semicolon, or the end of an
    enclosing group.  Then execute whatever follows in the normal way.
  endit()
  it() If you encounter an `tt(||)',
  startit()
    it() if the command before it succeeded, skip the next command and any
    others until an `tt(&&)' is encountered, or until the end of the group,
    and execute what follows normally
    it() else if the command failed, execute the command immediately
    after the `tt(||)'.
  endit()
endit()
If that's hard to follow, just note that the rule is completely
symmetric; a simple summary is that the logical connectors don't
remember their past state.  So in the example shown, the `tt(true)'
succeeds, we skip `tt(print foo)' but execute `tt(print bar)' and then
skip tt(false).  The expression returns status zero because the last
thing it executed did so.  Oddly enough, this is completely standard
behaviour for shells.  This is a roundabout way of saying `don't use
combined chains of `tt(&&)'s and `tt(||)'s unless you think Gödel's
theorem is for sissies'.

Strictly speaking, the and's and or's come in a hierarchy of things which
connect commands.  They are above pipelines, which explains my remark
above --- an expression like `tt(echo $ZSH_VERSION | sed '/dev//')' is
treated as a single command between any logical connectors --- and they are
below newlines and semicolons --- an expression like `tt(true && print yes;
false || print no)' is parsed as two distinct sets of logically connected
command sequences.  In the manual, a list is a complete set of commands
executed in one go:
verb(  echo foo; echo bar

  echo small furry animals)
--- a shell function is basically a glorified list with arguments and a
name.   A sublist is a set of commands up to a newline or
semicolon, in other words a complete expression possibly involving the
logical connectors:
verb(  show -nomoreproc | 
    grep -q foo && 
    print The word '`foo'\' occurs.)
A pipeline is a chain of one or more commands connected
by `tt(|)', for example both individual parts of the previous sublist,
verb(  show -nomoreproc | grep -q foo)
and
verb(  print The word '`foo'\' occurs.)
count as pipelines.  A simple command is one single unit of execution with a
command name, so to use the same example that includes all three of the
following,
verb(  show -nomoreproc
  grep -q foo
  print The word '`foo'\' occurs.)

This means that in something like
verb(  print foo)
where the command is terminated by a newline and then executed in one go,
the expression is all of the above --- list, sublist, pipeline and simple
command.  Mostly I won't need to make the formal distinction; it sometimes
helps when you need to break down a complicated set of commands.  It's a
good idea, and usually possible, to write in such a way that it's obvious
how the commands break down.  It's not too important to know the details,
as long as you've got a feel for how the shell finds the next command.

subsect(Structures)

I've shown plenty of examples of one sort of shell structure already, the
tt(if) statement:
verb(  if [[ black = white ]]; then
    print Yellow is no colour.
  fi)
The main points are: the `tt(if)' itself is followed by some command whose
return status is tested; a `tt(then)' follows as a new command; any number
of commands may follow, as complex as you like; the whole sequence is ended
by a `tt(fi)' as a command on its own.  You can write the `tt(then)' on a
new line if you like, I just happen to find it neater to stick it where it
is.  If you follow the form here, remember the semicolon before it; the
tt(then) must start a separate command.  (You can put another command
immediately after the tt(then) without a newline or semicolon, though,
although people tend not to.)

The double-bracketed test is by far the most common thing to put here in
zsh, as in ksh, but any command will do; only the status is important.
verb(  if true; then
    print This always gets executed
  fi
  if false; then
    print This never gets executed
  fi)
Here, tt(true) always returns true (status 0), while tt(false) always
returns false (status 1 in zsh, although some versions return status 255
--- anything nonzero will do).  So the statements following the tt(print)s
are correct.

The tt(if) construct can be extended by `tt(elif)' and `tt(else)':
verb(  read var
  if [[ $var = yes ]]; then
    print Read yes
  elif [[ $var = no ]]; then
    print Read no
  else
    print Read something else
  fi)
The extension is pretty straightforward.  You can have as many `tt(elif)'s
with different tests as you like; the code following the first test to
succeed is executed.  If no test succeeded, and there is an `tt(else)'
(there doesn't need to be), the code following that is executed.  Note
that the form of the `tt(elif)' is identical to that of `tt(if)',
including the `tt(then)', while the else just appears on its own.

The tt(while)-loop is quite similar to tt(if).  There are two
differences: the syntax uses tt(while), tt(do) and tt(done) instead of
tt(if), tt(then) and tt(fi), and after the loop body is executed (if it is),
the test is evaluated again.  The process stops as soon as the test is
false.  So
verb(  i=0
  while (( i++ < 3 )); do
    print $i
  done)
prints 1, then 2, then 3.  As with tt(if), the commands in the middle can
be any set of zsh commands, so
verb(  i=0
  while (( i++ < 3 )); do
    if (( i & 1 )); then
      print $i is odd
    else
      print $i is even
    fi
  done)
tells you that 1 and 3 are odd while 2 is even.  Remember that the
indentation is irrelevant; it is purely there to make the structures more
easy to understand.  You can write the code on a single line by replacing
all the newlines with semicolons.

There is also an tt(until) loop, which is identical to the tt(while) loop
except that the loop is executed until the test is true.  `tt(until
[[)em(...)' is equivalent to `tt(while ! [[)em(...)'.

Next comes the tt(for) loop.  The normal case can best be demonstrated by
another example:
verb(  for f in one two three; do
    print $f
  done)
which prints out `tt(one)' on the first iteration, then `tt(two)', then
`tt(three)'.  The tt(f) is set to each of the three words in turn, and the
body of the loop executed for each.  It is very useful that the words after
the `tt(in)' may be anything you would normally have on a shell command
line.  So `tt(for f in *; do)' will execute the body of the loop once for
each file in the current directory, with the file available as tt($f), and
you can use arrays or command substitutions or any other kind of
substitution to generate the words to loop over.

The tt(for) loop is so useful that the shell allows a shorthand that you
can use on the command line: try
verb(  for f in *; print $f)
and you will see the files in the current directory printed out, one per
line.  This form, without the tt(do) and the tt(done), involves less
typing, but is also less clear, so it is recommended that you only use it
interactively, not in scripts or functions.  You can turn the feature off
with tt(NO_SHORT_LOOPS).

The tt(case) statement is used to test a pattern against a series of
possibilities until one succeeds.  It is really a short way of doing
a series of tt(if) and tt(elif) tests on the same pattern:
verb(  read var
  case $var in
    (yes) print Read yes
          ;;
    (no) print Read no
         ;;
    (*) print Read something else
        ;;
   esac)
is identical to the tt(if)/tt(elif)/tt(else) example above.  The tt($var)
is compared against each pattern in turn; if one matches, the code
following that is executed --- then the statement is exited; no further
matches are looked for.  Hence the `tt(*)' at the end, which can match
anything, acts like the `tt(else)' of an tt(if) statement.

Note the quirks of the syntax: the pattern to test must appear in
parentheses.  For historical reasons, you can miss out the left
parenthesis before the pattern.  I haven't done that mainly because
unbalanced parentheses confuse the system I am using for writing this
guide.  Also, note the double semicolon: this is the only use of double
semicolons in the shell.  That explains the fact that if you type
`tt(;;)' on its own the shell will report a `parse error'; it couldn't
find a tt(case) to associate it with.

You can also use alternative patterns by separating them with a vertical
bar.  Zsh allows alternatives with extended globbing anyway; but this is
actually a separate feature, which is present in other shells which don't
have zsh's extended globbing feature; it doesn't depend on the
tt(EXTENDED_GLOB) option:
verb(  read var
  case $var in
    (yes|true|1) print Reply was affirmative
                 ;;
    (no|false|0) print Reply was negative
                 ;;
    (*) print Reply was cobblers
              ;;
  esac)
The first `tt(print)' is used if the value of tt($var) read in was
`tt(yes)', `tt(true)' or `tt(1)', and so on.  Each of the separate items
can be a pattern, with any of the special characters allowed by zsh,
this time depending on the setting of the option tt(EXTENDED_GLOB).

The tt(select) loop is not used all that often, in my experience.  It is
only useful with interactive input (though the code may certainly appear in
a script or function):
verb(  select var in earth air fire water; do
    print You selected $var
  done)
This prints a menu; you must type 1, 2, 3 or 4 to select the corresponding
item; then the body of the loop is executed with tt($var) set to the value
in the list corresponding to the number.  To exit the loop hit the break
key (usually tt(^G)) or end of file (usually tt(^D): the feature is
so infrequently used that currently there is a bug in the shell that this
tells you to use `tt(exit)' to exit, which is nonsense).  If the user
entered a bogus value, then the loop is executed with tt($var) set to the
empty string, though the actual input can be retrieved from tt($REPLY).
Note that the prompt printed for the user input is tt($PROMPT3), the only
use of this parameter in the shell: all normal prompt substitutions are
available.

There is one final type of loop which is special to zsh, unlike the others
above.  This is `tt(repeat)'.  It can be used two ways:
verb(  % repeat 3 print Hip Hip Hooray
  Hip Hip Hooray
  Hip Hip Hooray
  Hip Hip Hooray)
Here, the first word after tt(repeat) is a count, which could be a
variable as normal substitutions are performed.  The rest of the line (or
until the first semicolon) is a command to repeat; it is executed
identically each time.

The second form is a fully fledged loop, just like tt(while):
verb(  % repeat 3; do
  repeat> print Hip Hip Hooray
  repeat> done
  Hip Hip Hooray
  Hip Hip Hooray
  Hip Hip Hooray)
which has the identical effect to the previous one.  The `tt(repeat>)' is
the shell's prompt to show you that it is parsing the contents of a
`tt(repeat)' loop.

subsect(Subshells and current shell constructs)

More catching up with stuff you've already seen.  The expression in
parentheses here:
verb(  % (cd ~; ls)
  <all the files in my home directory>
  % pwd
  <where I was before, not necessarily ~>)
is run in a subshell, as if it were a script.  The main difference is that
the shell inherits almost everything from the main shell in which you are
typing, including options settings, functions and parameters.  The most
important thing it doesn't inherit is probably information about jobs: if
you run tt(jobs) in a subshell, you will get no output; you can't use
tt(fg) to resume a job in a subshell; you can't use `tt(kill %)em(n)' to
kill a job (though you can still use the process ID); and so on.  By now
you should have some feel for the effect of running in a separate process.
Running a command, or set of commands, in a different directory, as in this
example, is one quite common use for this construct.  (In zsh 4.1, you
can use tt(jobs) in a subshell; it lists the jobs running in the parent
shell; this is because it is very useful to be able to pipe the output
of jobs into some processing loop.)

On the other hand, the expression in braces here:
verb(  % {cd ~; ls}
  <all the files in my home directory>
  % pwd
  /home/pws)
is run in the current shell.  This is what I was blathering on about in
the section on redirection.  Indeed, unless you need some special effect
like redirecting a whole set of commands, you won't use the
current-shell construct.  The example here would behave just the same
way if the braces were missing.

As you might expect, the syntax of the subshell and current-shell forms is
very similar.  You can use redirection with both, just as with simple
commands, and they can appear in most places where a simple command can
appear:
verb(  [[ $test = true ]] && {
    print Hello.
    print Well, this is exciting.
  })
That would be much clearer using an `tt(if)', but it works.  For some
reason, you often find expressions of this form in system start-up files
located in the directory tt(/etc/rc.d) or, on older systems, in files
whose names begin with `tt(/etc/rc.)'.  You can even do:
verb(  if { foo=bar; [[ $foo = bar ]] }; then
    print yes
  fi)
but that's also pretty gross.

One use for tt({)em(...)tt(}) is to make sure a whole set of commands is
executed at once.  For example, if you copy a set of commands from a script
in one window and want them to be run in one go in a shell in another
window, you can do:
verb(   % {
   cursh>            # now paste your commands in here...
    ...
   cursh> })
and the commands will only be executed when you hit return after the final
`tt(})'.  This is also a workaround for some systems where cut and paste
has slightly odd effects due to the way different states of the terminal
are handled.  The current-shell construct is a little bit like an anonymous
function, although it doesn't have any of the usual features of functions
--- you can't pass it arguments, and variables declared inside aren't local
to that section of code.

subsect(Subshells and current shells)

In case you're confused about what happens in the current shell and what
happens in a subshell, here's a summary.

The following are run in the current shell.
enumerate(
  myeit() All shell builtins and anything which looks like one, such
     as a precommand modifier and tests with `tt([[)'.
  myeit() All complex statements and loops such as tt(if) and tt(while).
     Tests and code inside the block must both be considered separately.
  myeit() All shell functions.
  myeit() All files run by `tt(source)' or `tt(.)' as well as startup files.
  myeit() The code inside a `tt({)em(...)tt(})'.
  myeit() The right hand side of a pipeline: this is guaranteed in zsh, but
     don't rely on it for other shells.
  myeit() All forms of substitution except tt(`)em(...)tt(`),
     tt($)LPAR()em(...)RPAR(), tt(=)LPAR()em(...)RPAR(),
     tt(<)LPAR()em(...)RPAR() and tt(>)LPAR()em(...)RPAR().
)

The following are run in a subshell.
enumerate(
  myeit() All external commands.
  myeit() Anything on the left of a pipe, i.e. all sections of a
     pipeline but the last.
  myeit() The code inside a `tt()LPAR()em(...)RPAR()'.
  myeit() Substitutions involving execution of code,
     i.e. tt(`)em(...)tt(`), tt($)LPAR()em(...)RPAR(),
     tt(=)LPAR()em(...)RPAR(), tt(<)LPAR()em(...)RPAR() and
     tt(>)LPAR()em(...)RPAR().  (TCL fans note that this is different
     from the `tt([)em(...)tt(])' command substitution in that language.)
  myeit() Anything started in the background with `tt(&)' at the end.
  myeit() Anything which has ever been suspended.  This is a little subtle:
     suppose you execute a set of commands in the current shell and
     suspend it with tt(^Z).  Since the shell needs to return you to
     the prompt, it forks a subshell to remember the commands it was
     executing when you interrupted it.  If you use tt(fg) or tt(bg) to
     restart, the commands will stay in the subshell.  This is a special
     feature of zsh; most shells won't let you interrupt anything in the
     current shell like that, though you can still abort it with tt(^C).
)
With an alias, you can't tell where it will be executed --- you need to
find out what it expands too first.  The expansion naturally takes place in
the current shell.

Of course, if for some reason the current set of commands is already
running in a subshell, it doesn't get magically returned to the current
shell --- so a shell builtin on the left hand side of a pipeline is running
in a subshell.  However, it doesn't get an extra subshell, as an external
command would.  What I mean is:
verb(  { print Hello; cat file } |
    while read line; print $line; done)
The shell forks, producing a subshell, to execute the left hand side of the
pipeline, and that subshell forks to execute the tt(cat) external command,
but nothing else in that set of commands will cause a new subshell to be
created.

(For the curious only: actually, that's not quite true, and I already
pointed this out when I talked about command substitutions: the shell keeps
track of occasions when it is in a subshell and has no more commands to
execute. In this case it will not bother forking to create a new process
for the tt(cat), it will simply replace the subshell which is not needed
any more.  This can only happen in simple cases where the shell has no
clearing up to do.)

sect(Emulation and portability)

I described the options you need to set for compatibility with ksh in the
previous chapter.  Here I'm more interested in the best way of running ksh
scripts and functions.

First, you should remember that because of all zsh's options you can't
assume that a piece of zsh code will simply run a piece of sh or ksh code
without any extra changes.  Our old friend tt(SH_WORD_SPLIT) is the most
common problem, but there are plenty of others.  In addition to options,
there are other differences which simply need to be worked around.  I
will list some of them a bit later.  Generally speaking, Bourne shell is
simple enough that zsh emulates it pretty well --- although beware in case
you are using bash extensions, since to many Linux users bash is the
nearest approximation to the Bourne shell they ever come across.  Zsh makes
no attempt to emulate bash, even though some of bash's features have been
incorporated.

To make zsh emulate ksh or sh as closely as it knows how, there are various
things you can do.
enumerate(
  myeit() Invoke zsh under the name sh or ksh, as appropriate.  You can do
     this by creating a symbolic link from zsh to sh or ksh.  Then when
     zsh starts up all the options will be set appropriately.  If you
     are starting that shell from another zsh, you can use the feature
     of zsh that tricks a programme into thinking it has a different name:
     `tt(ARGV0=sh zsh)' runs zsh under the name sh, just like the symbolic
     link method.
  myeit() Use `tt(emulate ksh)' at the top of the script or function you
     want to run.  In the case of a function, it is better to run
     `tt(emulate -L ksh)' since this makes sure the normal options will
     be restored when the function exits; this is irrelevant for a script
     as the options cannot be propagated to the process which ran the
     script.  You can also use the option `tt(-R)' after tt(emulate), which
     forces more options to be like ksh; these extra options are generally
     for user convenience and not relevant to basic syntax, but in some
     cases you may want the extra cover provided.

     If it's possible the script may already be running under ksh, you
     can instead use
verb(  [[ -z $ZSH_VERSION ]] && emulate ksh)
     or for sh, using the simpler test command there,
verb(  [ x$ZSH_VERSION = x ] && emulate sh))
Both these methods have drawbacks, and if you plan to be a heavy zsh user
there's no substitute for simply getting used to zsh's own basic syntax.
If you think there is some useful element of emulation we missed, however,
you should certainly tell the zsh-workers mailing list about it.

Emulation of ksh88 is much better than emulation of ksh93.  Support for
the latter is gradually being added, but only patchily.

There is no easy way of converting code written for any csh-like shell; you
will just have to convert it by hand.  See the FAQ for some hints on
converting aliases to functions.

subsect(Differences in detail)

Here are some differences from ksh88 which might prove significant for ksh
programmers.  This is lifted straight from the corresponding section of the
FAQ; it is not complete, and indeed some of the `differences' could be
interpreted as bugs.  Those marked `*' perform in a ksh-like manner if the
shell is invoked with the name `ksh', or if `emulate ksh' is in effect.

itemize(
it() Syntax:
itemize(
  it()* Shell word splitting.
  it()* Arrays are (by default) more csh-like than ksh-like:
      subscripts start at 1, not 0; tt(array[0]) refers to tt(array[1]);
      mytt($array) refers to the whole array, not tt($array[0]);
      braces are unnecessary: tt($a[1] == ${a[1]}), etc.
      The tt(KSH_ARRAYS) option is now available.
  it()  Coprocesses are established by mytt(coproc); mytt(|&) behaves like
      csh.  Handling of coprocess file descriptors is also different.
  it()  In mytt(cmd1 && cmd2 &), only mytt(cmd2) instead of the whole
      expression is run in the background in zsh.  The manual implies
      this is a bug.  Use mytt({ cmd1 && cmd2 } &) as a workaround.)
it() Command line substitutions, globbing etc.:
itemize(
  it()* Failure to match a globbing pattern causes an error (use
      tt(NO_NOMATCH)).
  it()* The results of parameter substitutions are treated as plain text:
      mytt(foo="*"; print $foo) prints all files in ksh but mytt(*) in zsh
      (unset tt(GLOB_SUBST)).
  it()* tt($PSn) do not do parameter substitution by default (use \
tt(PROMPT_SUBST)).
  it()* Standard globbing does not allow ksh-style `pattern-lists'.
    See lref(chapter)(subst) for a list of equivalent zsh forms.
    The mytt(^), mytt(~) and mytt(#) (but not mytt(|)) forms require \
tt(EXTENDED_GLOB).
    From version 3.1.3, the ksh forms are fully supported when the
    option tt(KSH_GLOB) is in effect.

    [1] Note that mytt(~) is the only globbing operator to have a lower
      precedence than mytt(/).  For example, mytt(**/foo~*bar*) matches any
      file in a subdirectory called mytt(foo), except where mytt(bar)
      occurred somewhere in the path (e.g. mytt(users/barstaff/foo) will
      be excluded by the mytt(~) operator).  As the mytt(**) operator cannot
      be grouped (inside parentheses it is treated as mytt(*)), this is
      the way to exclude some subdirectories from matching a mytt(**).
  it()  Unquoted assignments do file expansion after colons (intended for
      PATHs).
  it()  mytt(integer) does not allow mytt(-i).
  it()  mytt(typeset) and mytt(integer) have special behaviour for
      assignments in ksh, but not in zsh.  For example, this doesn't
      work in zsh:
verb(        integer k=$(wc -l ~/.zshrc)
    )
      because the return value from tt(wc) includes leading
      whitespace which causes wordsplitting.  Ksh handles the
      assignment specially as a single word.)
it() Command execution:
itemize(
  it()* There is no tt($ENV) variable (use tt(/etc/zshrc), tt(~/.zshrc);
      note also tt($ZDOTDIR)).
  it()  tt($PATH) is not searched for commands specified
      at invocation without -c.)
it() Aliases and functions:
itemize(
  it()  The order in which aliases and functions are defined is significant:
      function definitions with () expand aliases.
  it()  Aliases and functions cannot be exported.
  it()  There are no tracked aliases: command hashing replaces these.
  it()  The use of aliases for key bindings is replaced by `bindkey'.
  it()* Options are not local to functions (use LOCAL_OPTIONS; note this
      may always be unset locally to propagate options settings from a
      function to the calling level).
)
  it() Traps and signals:
itemize(
  it()* Traps are not local to functions.  The option LOCAL_TRAPS is
        available from 3.1.6.
  it()  TRAPERR has become TRAPZERR (this was forced by UNICOS which
      has SIGERR).
)
it() Editing:
itemize(
  it()  The options tt(emacs), tt(gmacs), tt(viraw) are not supported.
      Use bindkey to change the editing behaviour: mytt(set -o {emacs,vi})
      becomes mytt(bindkey -{e,v}); for gmacs, go to emacs mode and use
      mytt(bindkey \^t gosmacs-transpose-characters).
  it()  The mytt(keyword) option does not exist and mytt(-k) is instead
      interactivecomments.  (mytt(keyword) will not be in the next ksh
      release either.)
  it()  Management of histories in multiple shells is different:
      the history list is not saved and restored after each command.
      The option tt(SHARE_HISTORY) appeared in 3.1.6 and is set in ksh
      compatibility mode to remedy this.
  it()  mytt(\) does not escape editing chars (use mytt(^V)).
  it()  Not all ksh bindings are set (e.g. mytt(<ESC>#); try mytt(<ESC>q)).
  it()* mytt(#) in an interactive shell is not treated as a comment by
      default.
)
it() Built-in commands:
itemize(
  it()  Some built-ins (tt(r), tt(autoload), tt(history), tt(integer) ...)
      were aliases in ksh.
  it()  There is no built-in command newgrp: use e.g. mytt(alias
      newgrp="exec newgrp")
  it()  mytt(jobs) has no mytt(-n) flag.
  it()  mytt(read) has no mytt(-s) flag.
)
it() Other idiosyncrasies:
itemize(
  it()  mytt(select) always redisplays the list of selections on each loop.
)
)

subsect(Making your own scripts and functions portable)

There are also problems in making your own scripts and functions
available to other people, who may have different options set.

In the case of functions, it is always best to put `tt(emulate -L zsh)'
at the top of the function, which will reset the options to the default
zsh values, and then set any other necessary options.  It doesn't take
the shell a great deal of time to process these commands, so try and
get into the habit of putting them any function you think may be used by
other people.  (Completion functions are a special case as the
environment is already standardised --- see lref(chapter)(comp) for this.)

The same applies to scripts, since if you run the script without using
the option `tt(-f)' to zsh the user's non-interactive startup files will
be run, and in any case the file tt(/etc/zshenv) will be run.  We urge
system administrators not to set options unconditionally in that file
unless absolutely necessary; but they don't always listen.  Hence an
tt(emulate) can still save a lot of grief.

sect(Running scripts)

Here are some final comments on running scripts: they apply regardless
of the problems of portability, but you should certainly also be aware
of what I was saying in the previous section.

You may be aware that you can force the operating system to run a script
using a particular interpreter by putting `tt(#!)' and the path to the
interpreter at the top of the script.  For example, a zsh script could
start with
verb(   #!/usr/local/bin/zsh
   print The arguments are $*)
assuming that zsh lives in the directory tt(/usr/local/bin).  Then you
can run the script under its name as if it were an ordinary command.
Suppose the script were called `tt(scriptfile)' and in the current
directory, and you want to run it with the arguments `tt(one two
forty-three)'.  First you must make sure the script is executable:
verb(  % chmod +x scriptfile)
and then you can run it with the arguments:
verb(  % ./scriptfile one two forty-three
  The arguments are one two forty-three)
The shell treats the first line as a comment, since it begins with a
`tt(#)', but note it still gets evaluated by the shell; the system
simply looks inside the file to see if what's there, it doesn't change
it just because the first line tells it to execute the shell.

I put the `tt(./)' in front to refer to the current directory because I
don't usually have that in my path --- this is for safety, to avoid
running things which happen to have names like commands simply because
they were in the current directory.  But many people aren't so paranoid,
and if `tt(.)'  is in your path, you can omit the `tt(./)'.  Hence,
obviously, it can be anywhere else in your path: it is searched for as
an ordinary executable.

The shell actually provides this mechanism even on operating systems
(now few and far between in the UNIX world) that don't have the feature
built into them.  The way this works is that if the shell found the
file, and it was executable, but running it didn't work, then it will
look for the tt(#!), extract the name following and run (in this
example) `tt(/usr/local/bin/zsh) var(<path>)/scriptfile tt(one two
forty-three)', where var(<path>) is the path where the file was found.
This is, in fact, pretty much what the system does if it handles it
itself.

Some shells search for scripts using the path when they are given as
filenames at invocation, but zsh happens not to.  In other words,
`tt(zsh scriptfile)' only runs tt(scriptfile) in the current directory.

There are two other features you may want to be aware of.  Both are down
to the operating system, if that is what is responsible for the `tt(#!)'
trick (true of all the most common UNIX-like systems at the moment).
First, you are usually allowed to supply one, but only one, argument or
option in the `tt(#!)' line, thus:
verb(  #!/usr/local/bin/zsh -f
  print other stuff here)
which stops startup files other than tt(/etc/zshenv) from being run, but
otherwise works the same as before.  If you need more options, you
should combine them in the same word.  However, it's usually clearer,
for anything apart from tt(-f), tt(-i) (which forces the shell into
interactive mode) and a few other options which need to take effect
immediately, to put a `tt(setopt)' line at the start of the body of the
script.  In a few versions of zsh, there was an unexpected consequence
of the fact that the line would only be split once: if you accidentally
left some spaces at the end of the line (e.g. `tt(#!/usr/local/bin/zsh
-f )') they would be passed down to the shell, which would report an
error, which was hard to interpret.  The spaces will still usually be
passed down, but the shell is now smart enough to ignore spaces in an
option list.

The second point is that the length of the `tt(#!)' line which will be
evaluated is limited.  Often the limit is 32 characters, in total, That
means if your path to zsh is long, e.g.
`tt(/home/users/psychology/research/dreams/freud/solaris_2.5/bin/zsh)'
the system won't be able to find the shell.  Your only recourse is to
find a shorter path, or execute the shell directly, or some sneakier
trick such as running the script under tt(/bin/sh) and making that start
zsh when it detects that zsh isn't running yet.  That's a fairly nasty
way of doing it, but just in case you find it necessary, here's an
example:
verb(  #!/bin/sh

  if [ x$ZSH_VERSION = x ]; then
    # Put the right path in here ---
    # or just rely on finding zsh in
    # $path, since `exec' handles that.
    exec /usr/local/bin/zsh $0 "$@"
  fi

  print $ZSH_VERSION
  print Hello, this is $0
  print with arguments $*.)
Note that first `tt($0)', which passes down the name of the script that was
originally executed.  Running this as `tt(testexec foo bar)' gives me
verb(  3.1.9-dev-8
  Hello, this is /home/pws/tmp/testexec
  with arguments foo bar.)
I hope you won't have to resort to that.  By the way, really,
excruciatingly old versions of zsh didn't have tt($ZSH_VERSION).  Rather
than fix the script, I suggest you upgrade the shell.  Also, on some old
Bourne shells you might need to replace tt("$@") with tt(${1+"$@"}),
which is more careful about only putting in arguments if there were any
(this is the sort of thing we'll see in lref(chapter)(subst)).  Usually
this isn't necessary.

You can use the same trick on ancient versions of UNIX which didn't
handle `tt(#!)'.  On some such systems, anything with a `tt(:)' as the
first character is run with the Bourne shell, so this serves as an
alternative to `tt(#!/bin/sh)', while on some Berkeley systems, a plain
`tt(#)' caused csh to be used.  In the second case, you will need to
change the syntax of the first test to be understood by both zsh and
csh.  I'll leave that as an exercise for the reader.  If you have perl
(very probable these days) you can look at the tt(perlrun) manual page,
which discusses the corresponding problem of starting perl scripts from
a shell, for some ideas.

There's one other glitch you may come across.  Sometimes if you type the
name of a script which you know is in your path and is executable, the
shell may tell you `tt(file not found)', or some equivalent message.
What this usually means is that the em(interpreter) wasn't found,
because you mistyped the line after the `tt(#!)'.  This confusing
message isn't the shell's fault: a lot of operating systems return the
same system error in this case as if the script were really not found.
It's not worth the shell searching the path to see if the script is
there, because in the vast majority of cases the error refers to the
programme in the execution path.  If the operating system returned the
more natural error, `tt(exec format error)', then the shell would know
that there was something wrong with the file, and could investigate; but
unfortunately life's not that simple.
