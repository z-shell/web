<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on March, 19  2004 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>zsh: User Contributions</TITLE>

<META NAME="description" CONTENT="zsh: User Contributions">
<META NAME="keywords" CONTENT="zsh: User Contributions">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC215"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_23.html#SEC214"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC216"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_23.html#SEC197"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 24. User Contributions </H1>
<!--docid::SEC215::-->
<A NAME="IDX1659"></A>
<P>

<HR SIZE="6">
<A NAME="SEC216"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC217"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC217"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.1 Description </H2>
<!--docid::SEC216::-->
<P>

The Zsh source distribution includes a number of items contributed by the
user community.  These are not inherently a part of the shell, and some
may not be available in every zsh installation.  The most significant of
these are documented here.  For documentation on other contributed items
such as shell functions, look for comments in the function source files.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="zsh_24.html#SEC217">24.2 Utilities</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="zsh_24.html#SEC222">24.3 Prompt Themes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="zsh_24.html#SEC225">24.4 ZLE Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="zsh_24.html#SEC228">24.5 MIME Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="zsh_24.html#SEC229">24.6 Other Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Utilities"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC217"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC216"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC218"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC222"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC222"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.2 Utilities </H2>
<!--docid::SEC217::-->
<P>

</P><P>

<HR SIZE="6">
<A NAME="SEC218"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC217"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC219"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.2.1 Accessing On-Line Help </H3>
<!--docid::SEC218::-->
<A NAME="IDX1660"></A>
<P>

The key sequence <TT>ESC h</TT> is normally bound by ZLE to execute the
<TT>run-help</TT> widget (see
<A HREF="zsh_17.html#SEC90">17. Zsh Line Editor</A>).  This invokes the <TT>run-help</TT> command with the command word from the
current input line as its argument.  By default, <TT>run-help</TT> is an alias
for the <TT>man</TT> command, so this often fails when the command word is a
shell builtin or a user-defined function.  By redefining the <TT>run-help</TT>
alias, one can improve the on-line help provided by the shell.
</P><P>

The <TT>helpfiles</TT> utility, found in the <TT>Util</TT> directory of the
distribution, is a Perl program that can be used to process the zsh manual
to produce a separate help file for each shell builtin and for many other
shell features as well.  The autoloadable <TT>run-help</TT> function, found in
<TT>Functions/Misc</TT>, searches for these helpfiles and performs several
other tests to produce the most complete help possible for the command.
</P><P>

There may already be a directory of help files on your system; look in
<TT>/usr/share/zsh</TT> or <TT>/usr/local/share/zsh</TT> and subdirectories below
those, or ask your system administrator.
</P><P>

To create your own help files with <TT>helpfiles</TT>, choose or create a
directory where the individual command help files will reside.  For
example, you might choose <TT>~/zsh_help</TT>.  If you unpacked the zsh
distribution in your home directory, you would use the commands:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>mkdir ~/zsh_help
cd ~/zsh_help
man zshall | colcrt - | \ 
perl ~/zsh-4.2.0-pre-4/Util/helpfiles
</pre></td></tr></table></P><P>

<A NAME="IDX1661"></A>
Next, to use the <TT>run-help</TT> function, you need to add lines something
like the following to your <TT>.zshrc</TT> or equivalent startup file:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>unalias run-help
autoload run-help
HELPDIR=~/zsh_help
</pre></td></tr></table></P><P>

<A NAME="IDX1662"></A>
The <TT>HELPDIR</TT> parameter tells <TT>run-help</TT> where to look for the help
files.  If your system already has a help file directory installed, set
<TT>HELPDIR</TT> to the path of that directory instead.
</P><P>

Note that in order for `<TT>autoload run-help</TT>' to work, the <TT>run-help</TT>
file must be in one of the directories named in your <TT>fpath</TT> array (see
<A HREF="zsh_14.html#SEC80">14.6 Parameters Used By The Shell</A>).  This should already be the case if you have a standard zsh
installation; if it is not, copy <TT>Functions/Misc/run-help</TT> to an
appropriate directory.
</P><P>

</P><P>

<HR SIZE="6">
<A NAME="SEC219"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC218"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC220"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC220"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.2.2 Recompiling Functions </H3>
<!--docid::SEC219::-->
<A NAME="IDX1663"></A>
<A NAME="IDX1664"></A>
<P>

If you frequently edit your zsh functions, or periodically update your zsh
installation to track the latest developments, you may find that function
digests compiled with the <TT>zcompile</TT> builtin are frequently out of date
with respect to the function source files.  This is not usually a problem,
because zsh always looks for the newest file when loading a function, but
it may cause slower shell startup and function loading.  Also, if a digest
file is explicitly used as an element of <TT>fpath</TT>, zsh won't check whether
any of its source files has changed.
</P><P>

The <TT>zrecompile</TT> autoloadable function, found in <TT>Functions/Misc</TT>, can
be used to keep function digests up to date.
</P><P>

<DL COMPACT>
<A NAME="IDX1665"></A>
<DT><TT>zrecompile</TT> [ <TT>-qt</TT> ] [ <VAR>name</VAR> ... ]
<DD><DT><TT>zrecompile</TT> [ <TT>-qt</TT> ] <TT>-p</TT> <VAR>args</VAR> [ <TT>-</TT><TT>-</TT> <VAR>args</VAR> ... ]
<DD>This tries to find <TT>*.zwc</TT> files and automatically re-compile them if at
least one of the original files is newer than the compiled file.  This
works only if the names stored in the compiled files are full paths or are
relative to the directory that contains the <TT>.zwc</TT> file.
<P>

In the first form, each <VAR>name</VAR> is the name of a compiled file or a
directory containing <TT>*.zwc</TT> files that should be checked.  If no
arguments are given, the directories and <TT>*.zwc</TT> files in <TT>fpath</TT> are
used.
</P><P>

When <TT>-t</TT> is given, no compilation is performed, but a return status of
zero (true) is set if there are files that need to be re-compiled and
non-zero (false) otherwise.  The <TT>-q</TT> option quiets the chatty output
that describes what <TT>zrecompile</TT> is doing.
</P><P>

Without the <TT>-t</TT> option, the return status is zero if all files that
needed re-compilation could be compiled and non-zero if compilation for at
least one of the files failed.
</P><P>

If the <TT>-p</TT> option is given, the <VAR>args</VAR> are interpreted as one
or more sets of arguments for <TT>zcompile</TT>, separated by `<TT>-</TT><TT>-</TT>'.
For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zrecompile -p \ 
           -R ~/.zshrc -- \ 
           -M ~/.zcompdump -- \ 
           ~/zsh/comp.zwc ~/zsh/Completion/*/_*
</pre></td></tr></table></P><P>

This compiles <TT>~/.zshrc</TT> into <TT>~/.zshrc.zwc</TT> if that doesn't exist or
if it is older than <TT>~/.zshrc</TT>. The compiled file will be marked for
reading instead of mapping. The same is done for <TT>~/.zcompdump</TT> and
<TT>~/.zcompdump.zwc</TT>, but this compiled file is marked for mapping. The
last line re-creates the file <TT>~/zsh/comp.zwc</TT> if any of the files
matching the given pattern is newer than it.
</P><P>

Without the <TT>-p</TT> option, <TT>zrecompile</TT> does not create function digests
that do not already exist, nor does it add new functions to the digest.
</P><P>

</DL>
<P>

The following shell loop is an example of a method for creating function
digests for all functions in your <TT>fpath</TT>, assuming that you have write
permission to the directories:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>for ((i=1; i &#60;= $#fpath; ++i)); do
  dir=$fpath[i]
  zwc=${dir:t}.zwc
  if [[ $dir == (.|..) || $dir == (.|..)/* ]]; then
    continue
  fi
  files=($dir/*(N-.))
  if [[ -w $dir:h &#38;&#38; -n $files ]]; then
    files=(${${(M)files%/*/*}#/})
    if ( cd $dir:h &#38;&#38;
         zrecompile -p -U -z $zwc $files ); then
      fpath[i]=$fpath[i].zwc
    fi
  fi
done
</pre></td></tr></table></P><P>

The <TT>-U</TT> and <TT>-z</TT> options are appropriate for functions in the default
zsh installation <TT>fpath</TT>; you may need to use different options for your
personal function directories.
</P><P>

Once the digests have been created and your <TT>fpath</TT> modified to refer to
them, you can keep them up to date by running <TT>zrecompile</TT> with no
arguments.
</P><P>

</P><P>

<HR SIZE="6">
<A NAME="SEC220"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC219"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC221"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC221"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.2.3 Keyboard Definition </H3>
<!--docid::SEC220::-->
<A NAME="IDX1666"></A>
<P>

<A NAME="IDX1667"></A>
The large number of possible combinations of keyboards, workstations,
terminals, emulators, and window systems makes it impossible for zsh to
have built-in key bindings for every situation.  The <TT>zkbd</TT> utility,
found in Functions/Misc, can help you quickly create key bindings for your
configuration.
</P><P>

Run <TT>zkbd</TT> either as an autoloaded function, or as a shell script:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zsh -f ~/zsh-4.2.0-pre-4/Functions/Misc/zkbd
</pre></td></tr></table></P><P>

When you run <TT>zkbd</TT>, it first asks you to enter your terminal type; if
the default it offers is correct, just press return.  It then asks you to
press a number of different keys to determine characteristics of your
keyboard and terminal; <TT>zkbd</TT> warns you if it finds anything out of the
ordinary, such as a Delete key that sends neither <TT>^H</TT> nor <TT>^?</TT>.
</P><P>

The keystrokes read by <TT>zkbd</TT> are recorded as a definition for an
associative array named <TT>key</TT>, written to a file in the subdirectory
<TT>.zkbd</TT> within either your <TT>HOME</TT> or <TT>ZDOTDIR</TT> directory.  The name
of the file is composed from the <TT>TERM</TT>, <TT>VENDOR</TT> and <TT>OSTYPE</TT>
parameters, joined by hyphens.
</P><P>

You may read this file into your <TT>.zshrc</TT> or another startup file with
the "source" or "." commands, then reference the <TT>key</TT> parameter in
bindkey commands, like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>source ${ZDOTDIR:-$HOME}/.zkbd/$TERM-$VENDOR-$OSTYPE
[[ -n ${key[Left]} ]] &#38;&#38; bindkey "${key[Left]}" backward-char
[[ -n ${key[Right]} ]] &#38;&#38; bindkey "${key[Right]}" forward-char
# etc.
</pre></td></tr></table></P><P>

Note that in order for `<TT>autoload zkbd</TT>' to work, the <TT>zkdb</TT> file must
be in one of the directories named in your <TT>fpath</TT> array (see
<A HREF="zsh_14.html#SEC80">14.6 Parameters Used By The Shell</A>).  This should already be the case if you have a standard zsh
installation; if it is not, copy <TT>Functions/Misc/zkbd</TT> to an
appropriate directory.
</P><P>

</P><P>

<HR SIZE="6">
<A NAME="SEC221"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC220"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC222"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.2.4 Dumping Shell State </H3>
<!--docid::SEC221::-->
<A NAME="IDX1668"></A>
<P>

Occasionally you may encounter what appears to be a bug in the shell,
particularly if you are using a beta version of zsh or a development
release.  Usually it is sufficient to send a description of the
problem to one of the zsh mailing lists (see
<A HREF="zsh_2.html#SEC6">2.3 Mailing Lists</A>), but sometimes one of the zsh developers will need to recreate your
environment in order to track the problem down.
</P><P>

The script named <TT>reporter</TT>, found in the <TT>Util</TT> directory of the
distribution, is provided for this purpose.  (It is also possible to
<TT>autoload reporter</TT>, but <TT>reporter</TT> is not installed in <TT>fpath</TT>
by default.)  This script outputs a detailed dump of the shell state,
in the form of another script that can be read with `<TT>zsh -f</TT>' to
recreate that state.
</P><P>

To use <TT>reporter</TT>, read the script into your shell with the `<TT>.</TT>'
command and redirect the output into a file:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>. ~/zsh-4.2.0-pre-4/Util/reporter &#62; zsh.report
</pre></td></tr></table></P><P>

You should check the <TT>zsh.report</TT> file for any sensitive information
such as passwords and delete them by hand before sending the script to the
developers.  Also, as the output can be voluminous, it's best to wait for
the developers to ask for this information before sending it.
</P><P>

You can also use <TT>reporter</TT> to dump only a subset of the shell state.
This is sometimes useful for creating startup files for the first time.
Most of the output from reporter is far more detailed than usually is
necessary for a startup file, but the <TT>aliases</TT>, <TT>options</TT>, and
<TT>zstyles</TT> states may be useful because they include only changes from
the defaults.  The <TT>bindings</TT> state may be useful if you have created
any of your own keymaps, because <TT>reporter</TT> arranges to dump the keymap
creation commands as well as the bindings for every keymap.
</P><P>

As is usual with automated tools, if you create a startup file with
<TT>reporter</TT>, you should edit the results to remove unnecessary commands.
Note that if you're using the new completion system, you should <EM>not</EM>
dump the <TT>functions</TT> state to your startup files with <TT>reporter</TT>; use
the <TT>compdump</TT> function instead (see
<A HREF="zsh_19.html#SEC112">19. Completion System</A>).
</P><P>

<DL COMPACT>
<DT><TT>reporter</TT> [ <VAR>state</VAR> ... ]
<DD><A NAME="IDX1669"></A>
Print to standard output the indicated subset of the current shell state.
The <VAR>state</VAR> arguments may be one or more of:
<P>

<DL COMPACT>
<DT><TT>all</TT>
<DD>Output everything listed below.
<DT><TT>aliases</TT>
<DD>Output alias definitions.
<DT><TT>bindings</TT>
<DD>Output ZLE key maps and bindings.
<DT><TT>completion</TT>
<DD>Output old-style <TT>compctl</TT> commands.
New completion is covered by <TT>functions</TT> and <TT>zstyles</TT>.
<DT><TT>functions</TT>
<DD>Output autoloads and function definitions.
<DT><TT>limits</TT>
<DD>Output <TT>limit</TT> commands.
<DT><TT>options</TT>
<DD>Output <TT>setopt</TT> commands.
<DT><TT>styles</TT>
<DD>Same as <TT>zstyles</TT>.
<DT><TT>variables</TT>
<DD>Output shell parameter assignments, plus <TT>export</TT>
commands for any environment variables.
<DT><TT>zstyles</TT>
<DD>Output <TT>zstyle</TT> commands.
</DL>
<P>

If the <VAR>state</VAR> is omitted, <TT>all</TT> is assumed.
</P><P>

With the exception of `<TT>all</TT>', every <VAR>state</VAR> can be abbreviated by
any prefix, even a single letter; thus <TT>a</TT> is the same as <TT>aliases</TT>,
<TT>z</TT> is the same as <TT>zstyles</TT>, etc.
</DL>
<P>

<A NAME="Prompt Themes"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC222"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC221"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC223"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC217"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC225"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.3 Prompt Themes </H2>
<!--docid::SEC222::-->
<P>

</P><P>

<HR SIZE="6">
<A NAME="SEC223"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC222"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC224"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.3.1 Installation </H3>
<!--docid::SEC223::-->
<P>

You should make sure all the functions from the <TT>Functions/Prompts</TT>
directory of the source distribution are available; they all begin with
the string `<TT>prompt_</TT>' except for the special function`<TT>promptinit</TT>'.
You also need the `<TT>colors</TT>' function from <TT>Functions/Misc</TT>.  All of
these functions may already have been installed on your system; if not,
you will need to find them and copy them.  The directory should appear as
one of the elements of the <TT>fpath</TT> array (this should already be the
case if they were installed), and at least the function <TT>promptinit</TT>
should be autoloaded; it will autoload the rest.  Finally, to initialize
the use of the system you need to call the <TT>promptinit</TT> function.  The
following code in your <TT>.zshrc</TT> will arrange for this; assume the
functions are stored in the directory <TT>~/myfns</TT>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>fpath=(~/myfns $fpath)
autoload -U promptinit
promptinit
</pre></td></tr></table></P><P>

</P><P>

<HR SIZE="6">
<A NAME="SEC224"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC223"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC225"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.3.2 Theme Selection </H3>
<!--docid::SEC224::-->
<P>

Use the <TT>prompt</TT> command to select your preferred theme.  This command
may be added to your <TT>.zshrc</TT> following the call to <TT>promptinit</TT> in
order to start zsh with a theme already selected.
</P><P>

<DL COMPACT>
<DT><TT>prompt</TT> [ <TT>-c</TT> | <TT>-l</TT> ]
<DD><DT><TT>prompt</TT> [ <TT>-p</TT> | <TT>-h</TT> ] [ <VAR>theme</VAR> ... ]
<DD><DT><TT>prompt</TT> [ <TT>-s</TT> ] <VAR>theme</VAR> [ <VAR>arg</VAR> ... ]
<DD>Set or examine the prompt theme.  With no options and a <VAR>theme</VAR>
argument, the theme with that name is set as the current theme.  The
available themes are determined at run time; use the <TT>-l</TT> option to see
a list.  The special <VAR>theme</VAR> `<TT>random</TT>' selects at random one of the
available themes and sets your prompt to that.
<P>

In some cases the <VAR>theme</VAR> may be modified by one or more arguments,
which should be given after the theme name.  See the help for each theme
for descriptions of these arguments.
</P><P>

Options are:
</P><P>

<DL COMPACT>
<DT><TT>-c</TT>
<DD>Show the currently selected theme and its parameters, if any.
<DT><TT>-l</TT>
<DD>List all available prompt themes.
<DT><TT>-p</TT>
<DD>Preview the theme named by <VAR>theme</VAR>, or all themes if no
<VAR>theme</VAR> is given.
<DT><TT>-h</TT>
<DD>Show help for the theme named by <VAR>theme</VAR>, or for the
<TT>prompt</TT> function if no <VAR>theme</VAR> is given.
<DT><TT>-s</TT>
<DD>Set <VAR>theme</VAR> as the current theme and save state.
</DL>
<P>

<DT><TT>prompt_</TT><VAR>theme</VAR><TT>_setup</TT>
<DD>Each available <VAR>theme</VAR> has a setup function which is called by the
<TT>prompt</TT> function to install that theme.  This function may define
other functions as necessary to maintain the prompt, including functions
used to preview the prompt or provide help for its use.  You should not
normally call a theme's setup function directly.
<P>

</DL>
<P>

<A NAME="ZLE Functions"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC225"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC224"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC226"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC222"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC228"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.4 ZLE Functions </H2>
<!--docid::SEC225::-->
<P>

</P><P>

<HR SIZE="6">
<A NAME="SEC226"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC225"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC227"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.4.1 Widgets </H3>
<!--docid::SEC226::-->
<P>

These functions all implement user-defined ZLE widgets (see
<A HREF="zsh_17.html#SEC90">17. Zsh Line Editor</A>) which can be bound to keystrokes in interactive shells.  To use them,
your <TT>.zshrc</TT> should contain lines of the form
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>autoload <VAR>function</VAR>
zle -N <VAR>function</VAR>
</pre></td></tr></table></P><P>

followed by an appropriate <TT>bindkey</TT> command to associate the function
with a key sequence.  Suggested bindings are described below.
</P><P>

<DL COMPACT>
<DT>bash-style word functions
<DD>If you are looking for functions to implement moving over and editing
words in the manner of bash, where only alphanumeric characters are
considered word characters, you can use the functions described in
the next section.  The following is sufficient:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>autoload -U select-word-style
select-word-style bash
</pre></td></tr></table></P><P>

</P><P>

<A NAME="IDX1670"></A>
<A NAME="IDX1671"></A>
<A NAME="IDX1672"></A>
<A NAME="IDX1673"></A>
<A NAME="IDX1674"></A>
<A NAME="IDX1675"></A>
<A NAME="IDX1676"></A>
<A NAME="IDX1677"></A>
<A NAME="IDX1678"></A>
<A NAME="IDX1679"></A>
<DT><TT>forward-word-match</TT>, <TT>backward-word-match</TT>
<DD><DT><TT>kill-word-match</TT>, <TT>backward-kill-word-match</TT>
<DD><DT><TT>transpose-words-match</TT>, <TT>capitalize-word-match</TT>
<DD><DT><TT>up-case-word-match</TT>, <TT>down-case-word-match</TT>
<DD><DT><TT>select-word-style</TT>, <TT>match-words-by-style</TT>
<DD>The eight `<TT>-match</TT>' functions are drop-in replacements for the
builtin widgets without the suffix.  By default they behave in a similar
way.  However, by the use of styles and the function <TT>select-word-style</TT>,
the way words are matched can be altered.
<P>

The simplest way of configuring the functions is to use
<TT>select-word-style</TT>, which can either be called as a normal function with
the appropriate argument, or invoked as a user-defined widget that will
prompt for the first character of the word style to be used.  The first
time it is invoked, the eight <TT>-match</TT> functions will automatically
replace the builtin versions, so they do not need to be loaded explicitly.
</P><P>

The word styles available are as follows.  Only the first character
is examined.
</P><P>

<DL COMPACT>
<DT><TT>bash</TT>
<DD>Word characters are alphanumeric characters only.
<P>

<DT><TT>normal</TT>
<DD>As in normal shell operation:  word characters are alphanumeric characters
plus any characters present in the string given by the parameter
<TT>$WORDCHARS</TT>.
<P>

<DT><TT>shell</TT>
<DD>Words are complete shell command arguments, possibly including complete
quoted strings, or any tokens special to the shell.
<P>

<DT><TT>whitespace</TT>
<DD>Words are any set of characters delimited by whitespace.
<P>

<DT><TT>default</TT>
<DD>Restore the default settings; this is usually the same as `<TT>normal</TT>'.
<P>

</DL>
<P>

More control can be obtained using the <TT>zstyle</TT> command, as described in
<A HREF="zsh_21.html#SEC182">21.31 The zsh/zutil Module</A>.  Each style is looked up in the
context <TT>:zle:</TT><VAR>widget</VAR> where <VAR>widget</VAR> is the name of the
user-defined widget, not the name of the function implementing it, so in
the case of the definitions supplied by <TT>select-word-style</TT> the
appropriate contexts are <TT>:zle:forward-word</TT>, and so on.  The function
<TT>select-word-style</TT> itself always defines styles for the context
`<TT>:zle:*</TT>' which can be overridden by more specific (longer) patterns as
well as explicit contexts.
</P><P>

The style <TT>word-style</TT> specifies the rules to use.  This may have the
following values.
</P><P>

<DL COMPACT>
<DT><TT>normal</TT>
<DD>Use the standard shell rules, i.e. alphanumerics and <TT>$WORDCHARS</TT>, unless
overridden by the styles <TT>word-chars</TT> or <TT>word-class</TT>.
<P>

<DT><TT>specified</TT>
<DD>Similar to <TT>normal</TT>, but <EM>only</EM> the specified characters, and not also
alphanumerics, are considered word characters.
<P>

<DT><TT>unspecified</TT>
<DD>The negation of specified.  The given characters are those which will
<EM>not</EM> be considered part of a word.
<P>

<DT><TT>shell</TT>
<DD>Words are obtained by using the syntactic rules for generating shell
command arguments.  In addition, special tokens which are never command
arguments such as `<TT>()</TT>' are also treated as words.
<P>

<DT><TT>whitespace</TT>
<DD>Words are whitespace-delimited strings of characters.
<P>

</DL>
<P>

The first three of those styles usually use <TT>$WORDCHARS</TT>, but the value
in the parameter can be overridden by the style <TT>word-chars</TT>, which works
in exactly the same way as <TT>$WORDCHARS</TT>.  In addition, the style
<TT>word-class</TT> uses character class syntax to group characters and takes
precedence over <TT>word-chars</TT> if both are set.  The <TT>word-class</TT> style
does not include the surrounding brackets of the character class; for
example, `<TT>-:[:alnum:]</TT>' is a valid <TT>word-class</TT> to include all
alphanumerics plus the characters `<TT>-</TT>' and `<TT>:</TT>'.  Be careful
including `<TT>]</TT>', `<TT>^</TT>' and `<TT>-</TT>' as these are special inside
character classes.
</P><P>

The final style is <TT>skip-chars</TT>.  This is mostly useful for
<TT>transpose-words</TT> and similar functions.  If set, it gives a count of
characters starting at the cursor position which will not be considered
part of the word and are treated as space, regardless of what they actually
are.  For example, if
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle ':zle:transpose-words' skip-chars 1
</pre></td></tr></table></P><P>

has been set, and <TT>transpose-words-match</TT> is called with the cursor on
the <VAR>X</VAR> of <TT>foo</TT><VAR>X</VAR><TT>bar</TT>, where <VAR>X</VAR> can be any character, then
the resulting expression is <TT>bar</TT><VAR>X</VAR><TT>foo</TT>.
</P><P>

Here are some examples of use of the styles, actually taken from the
simplified interface in <TT>select-word-style</TT>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle ':zle:*' word-style standard
zstyle ':zle:*' word-chars ''
</pre></td></tr></table></P><P>

Implements bash-style word handling for all widgets, i.e. only
alphanumerics are word characters; equivalent to setting
the parameter <TT>WORDCHARS</TT> empty for the given context.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>style ':zle:*kill*' word-style space
</pre></td></tr></table></P><P>

Uses space-delimited words for widgets with the word `kill' in the name.
Neither of the styles <TT>word-chars</TT> nor <TT>word-class</TT> is used in this case.
</P><P>

The word matching and all the handling of <TT>zstyle</TT> settings is actually
implemented by the function <TT>match-words-by-style</TT>.  This can be used to
create new user-defined widgets.  The calling function should set the local
parameter <TT>curcontext</TT> to <TT>:zle:</TT><VAR>widget</VAR>, create the local
parameter <TT>matched_words</TT> and call <TT>match-words-by-style</TT> with no
arguments.  On return, <TT>matched_words</TT> will be set to an array with the
elements: (1) the start of the line (2) the word before the cursor (3) any
non-word characters between that word and the cursor (4) any non-word
character at the cursor position plus any remaining non-word characters
before the next word, including all characters specified by the
<TT>skip-chars</TT> style, (5) the word at or following the cursor (6) any
non-word characters following that word (7) the remainder of the line.  Any
of the elements may be an empty string; the calling function should test
for this to decide whether it can perform its function.
</P><P>

<A NAME="IDX1680"></A>
<DT><TT>delete-whole-word-match</TT>
<DD>This is another function which works like the <TT>-match</TT> functions
described immediately above, i.e. using styles to decide the word
boundaries.  However, it is not a replacement for any existing function.
<P>

The basic behaviour is to delete the word around the cursor.  There is no
numeric prefix handling; only the single word around the cursor is
considered.  If the widget contains the string <TT>kill</TT>, the removed text
will be placed in the cutbuffer for future yanking.  This can be obtained
by defining <TT>kill-whole-word-match</TT> as follows:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zle -N kill-whole-word-match delete-whole-word-match
</pre></td></tr></table></P><P>

and then binding the widget <TT>kill-whole-word-match</TT>.
</P><P>

<A NAME="IDX1681"></A>
<DT><TT>copy-earlier-word</TT>
<DD>This widget works like a combination of <TT>insert-last-word</TT> and
<TT>copy-prev-shell-word</TT>.  Repeated invocations of the widget retrieve
earlier words on the relevant history line.  With a numeric argument
<VAR>N</VAR>, insert the <VAR>N</VAR>th word from the history line; <VAR>N</VAR> may be
negative to count from the end of the line.
<P>

If <TT>insert-last-word</TT> has been used to retrieve the last word on a
previous history line, repeated invocations will replace that word with
earlier words from the same line.
</P><P>

Otherwise, the widget applies to words on the line currently being edited.
The <TT>widget</TT> style can be set to the name of another widget that should
be called to retrieve words.  This widget must accept the same three
arguments as <TT>insert-last-word</TT>.
</P><P>

<A NAME="IDX1682"></A>
<DT><TT>cycle-completion-positions</TT>
<DD>After inserting an unambiguous string into the command line, the new
function based completion system may know about multiple places in
this string where characters are missing or differ from at least one
of the possible matches.  It will then place the cursor on the
position it considers to be the most interesting one, i.e. the one
where one can disambiguate between as many matches as possible with as 
little typing as possible.
<P>

This widget allows the cursor to be easily moved to the other interesting
spots.  It can be invoked repeatedly to cycle between all positions
reported by the completion system.
</P><P>

<A NAME="IDX1683"></A>
<DT><TT>edit-command-line</TT>
<DD>Edit the command line using your visual editor, as in <TT>ksh</TT>.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bindkey -M vicmd v edit-command-line
</pre></td></tr></table></P><P>

<A NAME="IDX1684"></A>
<A NAME="IDX1685"></A>
<DT><TT>history-search-end</TT>
<DD>This function implements the widgets
<TT>history-beginning-search-backward-end</TT> and
<TT>history-beginning-search-forward-end</TT>.  These commands work by first
calling the corresponding builtin widget (see
<A HREF="zsh_17.html#SEC100">17.6.2 History Control</A>) and then moving the cursor to the end of the line.  The original cursor
position is remembered and restored before calling the builtin widget a
second time, so that the same search is repeated to look farther through
the history.
<P>

Although you <TT>autoload</TT> only one function, the commands to use it are
slightly different because it implements two widgets.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zle -N history-beginning-search-backward-end \ 
       history-search-end
zle -N history-beginning-search-forward-end \ 
       history-search-end
bindkey '\e^P' history-beginning-search-backward-end
bindkey '\e^N' history-beginning-search-forward-end
</pre></td></tr></table></P><P>

<A NAME="IDX1686"></A>
<A NAME="IDX1687"></A>
<DT><TT>up-line-or-beginning-search</TT>, <TT>down-line-or-beginning-search</TT>
<DD>These widgets are similar to the builtin functions <TT>up-line-or-search</TT>
and <TT>down-line-or-search</TT>:  if in a multiline buffer they move up or
down within the buffer, otherwise they search for a history line matching
the start of the current line.  In this case, however, they search for
a line which matches the current line up to the current cursor position, in
the manner of <TT>history-beginning-search-backward</TT> and <TT>-forward</TT>, rather
than the first word on the line.
<P>

<A NAME="IDX1688"></A>
<A NAME="IDX1689"></A>
<DT><TT>incarg</TT>
<DD>Typing the keystrokes for this widget with the cursor placed on or to the
left of an integer causes that integer to be incremented by one.  With a
numeric prefix argument, the number is incremented by the amount of the
argument (decremented if the prefix argument is negative).  The shell
parameter <TT>incarg</TT> may be set to change the default increment something
other than one.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bindkey '^X+' incarg
</pre></td></tr></table></P><P>

<A NAME="IDX1690"></A>
<DT><TT>incremental-complete-word</TT>
<DD>This allows incremental completion of a word.  After starting this
command, a list of completion choices can be shown after every character
you type, which you can delete with <TT>^H</TT> or <TT>DEL</TT>.  Pressing return
accepts the completion so far and returns you to normal editing (that is,
the command line is <EM>not</EM> immediately executed).  You can hit <TT>TAB</TT> to
do normal completion, <TT>^G</TT> to abort back to the state when you started,
and <TT>^D</TT> to list the matches.
<P>

This works only with the new function based completion system.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bindkey '^Xi' incremental-complete-word
</pre></td></tr></table></P><P>

<A NAME="IDX1691"></A>
<DT><TT>insert-files</TT>
<DD>This function allows you type a file pattern, and see the results of the
expansion at each step.  When you hit return, all expansions are inserted
into the command line.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>bindkey '^Xf' insert-files
</pre></td></tr></table></P><P>

<A NAME="IDX1692"></A>
<A NAME="IDX1693"></A>
<DT><TT>narrow-to-region [ -p</TT> <VAR>pre</VAR> <TT>] [ -P</TT> <VAR>post</VAR> <TT>]</TT>
<DD><DT><TT>[ -S</TT> <VAR>statepm</VAR> <TT>| -R</TT> <VAR>statepm</VAR> <TT>] [ -n ] [</TT> <VAR>start</VAR> <VAR>end</VAR> <TT>]</TT>)
<DD><DT><TT>narrow-to-region-invisible</TT>
<DD>Narrow the editable portion of the buffer to the region between the cursor
and the mark, which may be in either order.  The region may not be empty.
<P>

<TT>narrow-to-region</TT> may be used as a widget or called as a function from a
user-defined widget; by default, the text outside the editable area remains
visible.  A <TT>recursive-edit</TT> is performed and the original widening
status is then restored.  Various options and arguments are available when
it is called as a function.
</P><P>

The options <TT>-p</TT> <VAR>pretext</VAR> and <TT>-P</TT> <VAR>posttext</VAR> may be
used to replace the text before and after the display for the duration of
the function; either or both may be an empty string.
</P><P>

If the option <TT>-n</TT> is also given, <VAR>pretext</VAR> or <VAR>posttext</VAR> will only
be inserted if there is text before or after the region respectively which
will be made invisible.
</P><P>

Two numeric arguments may be given which will be used instead of the cursor
and mark positions.
</P><P>

The option <TT>-S</TT> <VAR>statepm</VAR> is used to narrow according to the other
options while saving the original state in the parameter with name
<VAR>statepm</VAR>, while the option <TT>-R</TT> <VAR>statepm</VAR> is used to restore the
state from the parameter; note in both cases the <EM>name</EM> of the parameter
is required.  In the second case, other options and arguments are
irrelevant.  When this method is used, no <TT>recursive-edit</TT> is performed;
the calling widget should call this function with the option <TT>-S</TT>,
perform its own editing on the command line or pass control to the user
via `<TT>zle recursive-edit</TT>', then call this function with the option
<TT>-R</TT>.  The argument <VAR>statepm</VAR> must be a suitable name for an ordinary
parameter, except that parameters beginning with the prefix <TT>_ntr_</TT> are
reserved for use within <TT>narrow-to-region</TT>.  Typically the parameter will
be local to the calling function.
</P><P>

<TT>narrow-to-region-invisible</TT> is a simple widget which calls
<TT>narrow-to-region</TT> with arguments which replace any text outside the
region with `<TT>...</TT>'.
</P><P>

The display is restored (and the widget returns) upon any zle command
which would usually cause the line to be accepted or aborted.  Hence an
additional such command is required to accept or abort the current line.
</P><P>

The return status of both widgets is zero if the line was accepted, else
non-zero.
</P><P>

Here is a trivial example of a widget using this feature.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>local state
narrow-to-region -p $'Editing restricted region\n' \ 
  -P '' -S state
zle recursive-edit
narrow-to-region -R state
</pre></td></tr></table></P><P>

<A NAME="IDX1694"></A>
<A NAME="IDX1695"></A>
<DT><TT>predict-on</TT>
<DD>This set of functions implements predictive typing using history search.
After <TT>predict-on</TT>, typing characters causes the editor to look backward
in the history for the first line beginning with what you have typed so
far.  After <TT>predict-off</TT>, editing returns to normal for the line found.
In fact, you often don't even need to use <TT>predict-off</TT>, because if the
line doesn't match something in the history, adding a key performs
standard completion, and then inserts itself if no completions were found.
However, editing in the middle of a line is liable to confuse prediction;
see the <TT>toggle</TT> style below.
<P>

With the function based completion system (which is needed for this), you
should be able to type <TT>TAB</TT> at almost any point to advance the cursor
to the next "interesting" character position (usually the end of the
current word, but sometimes somewhere in the middle of the word).  And of
course as soon as the entire line is what you want, you can accept with
return, without needing to move the cursor to the end first.
</P><P>

The first time <TT>predict-on</TT> is used, it creates several additional
widget functions:
</P><P>

<DL COMPACT>
<DT><TT>delete-backward-and-predict</TT>
<DD>Replaces the <TT>backward-delete-char</TT>
widget.  You do not need to bind this yourself.
<DT><TT>insert-and-predict</TT>
<DD>Implements predictive typing by replacing the
<TT>self-insert</TT> widget.  You do not need to bind this yourself.
<DT><TT>predict-off</TT>
<DD>Turns off predictive typing.
</DL>
<P>

Although you <TT>autoload</TT> only the <TT>predict-on</TT> function, it is
necessary to create a keybinding for <TT>predict-off</TT> as well.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zle -N predict-on
zle -N predict-off
bindkey '^X^Z' predict-on
bindkey '^Z' predict-off
</pre></td></tr></table></P><P>

<A NAME="IDX1696"></A>
<DT><TT>read-from-minibuffer</TT>
<DD>This is most useful when called as a function from inside a widget, but will
work correctly as a widget in its own right.  It prompts for a value
below the current command line; a value may be input using all of the
standard zle operations (and not merely the restricted set available
when executing, for example, <TT>execute-named-cmd</TT>).  The value is then
returned to the calling function in the parameter <TT>$REPLY</TT> and the
editing buffer restored to its previous state.  If the read was aborted
by a keyboard break (typically <TT>^G</TT>), the function returns status 1
and <TT>$REPLY</TT> is not set.  If an argument is supplied to the function
it is taken as a prompt, otherwise `<TT>? </TT>' is used.
<P>

One option is available: `<TT>-k</TT> <VAR>num</VAR>' specifies that <VAR>num</VAR>
characters are to be read instead of a whole line.  The line editor is not
invoked recursively in this case.  Note that unlike the <TT>read</TT> builtin
<VAR>num</VAR> must be given; there is no default.
</P><P>

The name is a slight misnomer, as in fact the shell's own minibuffer is
not used.  Hence it is still possible to call <TT>executed-named-cmd</TT> and
similar functions while reading a value.
</P><P>

<A NAME="IDX1697"></A>
<A NAME="IDX1698"></A>
<DT><TT>replace-string</TT>, <TT>replace-pattern</TT>
<DD>The function <TT>replace-string</TT> implements two widgets.
If defined under the same name as the function, it prompts for two
strings; the first (source) string will be replaced by the second
everywhere it occurs in the line editing buffer.
<P>

If the widget name contains the word `<TT>pattern</TT>', for example by
defining the widget using the command `<TT>zle -N replace-pattern
replace-string</TT>', then the replacement is done by pattern matching.  All
zsh extended globbing patterns can be used in the source string; note
that unlike filename generation the pattern does not need to match an
entire word, nor do glob qualifiers have any effect.  In addition, the
replacement string can contain parameter or command substitutions.
Furthermore, a `<TT>&#38;</TT>' in the replacement string will be replaced with
the matched source string, and a backquoted digit `<TT>\</TT><VAR>N</VAR>' will be
replaced by the <VAR>N</VAR>th parenthesised expression matched.  The form
`<TT>\{</TT><VAR>N</VAR><TT>}</TT>' may be used to protect the digit from following
digits.
</P><P>

For example, starting from the line:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>print This line contains fan and fond
</pre></td></tr></table></P><P>

and invoking <TT>replace-pattern</TT> with the source string `<TT>f(?)n</TT>' and
the replacment string `<TT>c\1r</TT>' produces the not very useful line:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>print This line contains car and cord
</pre></td></tr></table></P><P>

The range of the replacement string can be limited by using the
<TT>narrow-to-region-invisible</TT> widget.  One limitation of the current
version is that <TT>undo</TT> will cycle through changes to the replacement
and source strings before undoing the replacement itself.
</P><P>

<A NAME="IDX1699"></A>
<DT><TT>smart-insert-last-word</TT>
<DD>This function may replace the <TT>insert-last-word</TT> widget, like so:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zle -N insert-last-word smart-insert-last-word
</pre></td></tr></table></P><P>

With a numeric prefix, or when passed command line arguments in a call
from another widget, it behaves like <TT>insert-last-word</TT>, except that
words in comments are ignored when <TT>INTERACTIVE_COMMENTS</TT> is set.
</P><P>

Otherwise, the rightmost "interesting" word from the previous command is
found and inserted.  The default definition of "interesting" is that the
word contains at least one alphabetic character, slash, or backslash.
This definition may be overridden by use of the <TT>match</TT> style.  The
context used to look up the style is the widget name, so usually the
context is <TT>:insert-last-word</TT>.  However, you can bind this function to
different widgets to use different patterns:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zle -N insert-last-assignment smart-insert-last-word
zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'
bindkey '\e=' insert-last-assignment
</pre></td></tr></table></P><P>

</DL>
<P>

</P><P>

<HR SIZE="6">
<A NAME="SEC227"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC226"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC228"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.4.2 Styles </H3>
<!--docid::SEC227::-->
<P>

The behavior of several of the above widgets can be controlled by the use
of the <TT>zstyle</TT> mechanism.  In particular, widgets that interact with
the completion system pass along their context to any completions that
they invoke.
</P><P>

<DL COMPACT>
<A NAME="IDX1700"></A>
<DT><TT>break-keys</TT>
<DD>This style is used by the <TT>incremental-complete-word</TT> widget. Its value
should be a pattern, and all keys matching this pattern will cause the
widget to stop incremental completion without the key having any further
effect. Like all styles used directly by
<TT>incremental-complete-word</TT>, this style is looked up using the
context `<TT>:incremental</TT>'.
<P>

<A NAME="IDX1701"></A>
<DT><TT>completer</TT>
<DD>The <TT>incremental-complete-word</TT> and <TT>insert-and-predict</TT> widgets set
up their top-level context name before calling completion.  This allows
one to define different sets of completer functions for normal completion
and for these widgets.  For example, to use completion, approximation and
correction for normal completion, completion and correction for
incremental completion and only completion for prediction one could use:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle ':completion:*' completer \ 
        _complete _correct _approximate
zstyle ':completion:incremental:*' completer \ 
        _complete _correct
zstyle ':completion:predict:*' completer \ 
        _complete
</pre></td></tr></table></P><P>

It is a good idea to restrict the completers used in prediction, because
they may be automatically invoked as you type.  The <TT>_list</TT> and
<TT>_menu</TT> completers should never be used with prediction.  The
<TT>_approximate</TT>, <TT>_correct</TT>, <TT>_expand</TT>, and <TT>_match</TT> completers may
be used, but be aware that they may change characters anywhere in the word
behind the cursor, so you need to watch carefully that the result is what
you intended.
</P><P>

<A NAME="IDX1702"></A>
<DT><TT>cursor</TT>
<DD>The <TT>insert-and-predict</TT> widget uses this style, in the context
`<TT>:predict</TT>', to decide where to place the cursor after completion has
been tried.  Values are:
<P>

<DL COMPACT>
<DT><TT>complete</TT>
<DD>The cursor is left where it was when completion finished, but only if
it is after a character equal to the one just inserted by the user.  If 
it is after another character, this value is the same as `<TT>key</TT>'.
<P>

<DT><TT>key</TT>
<DD>The cursor is left
after the <VAR>n</VAR>th occurrence of the character just inserted, where
<VAR>n</VAR> is the number of times that character appeared in the word
before completion was attempted.  In short, this has the effect of
leaving the cursor after the character just typed even if the
completion code found out that no other characters need to be inserted 
at that position.
<P>

</DL>
<P>

Any other value for this style unconditionally leaves the cursor at the
position where the completion code left it.
</P><P>

<A NAME="IDX1703"></A>
<DT><TT>list</TT>
<DD>When using the <TT>incremental-complete-word</TT> widget, this style says
if the matches should be listed on every key press (if they fit on the 
screen).  Use the context prefix `<TT>:completion:incremental</TT>'.
<P>

The <TT>insert-and-predict</TT> widget uses this style to decide if the
completion should be shown even if there is only one possible completion.
This is done if the value of this style is the string <TT>always</TT>.  In this
case the context is `<TT>:predict</TT>' (<EM>not</EM> `<TT>:completion:predict</TT>').
</P><P>

<A NAME="IDX1704"></A>
<DT><TT>match</TT>
<DD>This style is used by <TT>smart-insert-last-word</TT> to provide a pattern
(using full <TT>EXTENDED_GLOB</TT> syntax) that matches an interesting word.
The context is the name of the widget to which <TT>smart-insert-last-word</TT>
is bound (see above).  The default behavior of <TT>smart-insert-last-word</TT>
is equivalent to:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle :insert-last-word match '*[[:alpha:]/\\]*'
</pre></td></tr></table></P><P>

However, you might want to include words that contain spaces:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle :insert-last-word match '*[[:alpha:][:space:]/\\]*'
</pre></td></tr></table></P><P>

Or include numbers as long as the word is at least two characters long:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\])*'
</pre></td></tr></table></P><P>

The above example causes redirections like "2>" to be included.
</P><P>

<A NAME="IDX1705"></A>
<DT><TT>prompt</TT>
<DD>The <TT>incremental-complete-word</TT> widget shows the value of this
style in the status line during incremental completion.  The string
value may contain any of the following substrings in the manner of
the <TT>PS1</TT> and other prompt parameters:
<P>

<DL COMPACT>
<DT><TT>%c</TT>
<DD>Replaced by the name of the completer function that generated the
matches (without the leading underscore).
<P>

<DT><TT>%l</TT>
<DD>When the <TT>list</TT> style is set,
replaced by `<TT>...</TT>' if the list of matches is too long to fit on the
screen and with an empty string otherwise.  If the <TT>list</TT> style is
`false' or not set, `<TT>%l</TT>' is always removed.
<P>

<DT><TT>%n</TT>
<DD>Replaced by the number of matches generated.
<P>

<DT><TT>%s</TT>
<DD>Replaced by `<TT>-no match-</TT>', `<TT>-no prefix-</TT>', or an empty string
if there is no completion matching the word on the line, if the
matches have no common prefix different from the word on the line, or
if there is such a common prefix, respectively.
<P>

<DT><TT>%u</TT>
<DD>Replaced by the unambiguous part of all matches, if there
is any, and if it is different from the word on the line.
<P>

</DL>
<P>

Like `<TT>break-keys</TT>', this uses the `<TT>:incremental</TT>' context.
</P><P>

<A NAME="IDX1706"></A>
<DT><TT>stop-keys</TT>
<DD>This style is used by the <TT>incremental-complete-word</TT> widget.  Its value
is treated similarly to the one for the <TT>break-keys</TT> style (and uses 
the same context: `<TT>:incremental</TT>').  However, in
this case all keys matching the pattern given as its value will stop
incremental completion and will then execute their usual function.
<P>

<A NAME="IDX1707"></A>
<DT><TT>toggle</TT>
<DD>This boolean style is used by <TT>predict-on</TT> and its related widgets in
the context `<TT>:predict</TT>'.  If set to one of the standard `true' values,
predictive typing is automatically toggled off in situations where it is
unlikely to be useful, such as when editing a multi-line buffer or after
moving into the middle of a line and then deleting a character.  The
default is to leave prediction turned on until an explicit call to
<TT>predict-off</TT>.
<P>

<A NAME="IDX1708"></A>
<DT><TT>verbose</TT>
<DD>This boolean style is used by <TT>predict-on</TT> and its related widgets in
the context `<TT>:predict</TT>'.  If set to one of the standard `true' values,
these widgets display a message below the prompt when the predictive state
is toggled.  This is most useful in combination with the <TT>toggle</TT> style.
The default does not display these messages.
<P>

<A NAME="IDX1709"></A>
<DT><TT>widget</TT>
<DD>This style is similar to the <TT>command</TT> style: For widget functions that
use <TT>zle</TT> to call other widgets, this style can sometimes be used to
override the widget which is called.  The context for this style is the
name of the calling widget (<EM>not</EM> the name of the calling function,
because one function may be bound to multiple widget names).
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle :copy-earlier-word widget smart-insert-last-word
</pre></td></tr></table></P><P>

Check the documentation for the calling widget or function to determine
whether the <TT>widget</TT> style is used.
</P><P>

</DL>
<P>

<A NAME="MIME Functions"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC228"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC227"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC229"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC225"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.5 MIME Functions </H2>
<!--docid::SEC228::-->
<P>

Three functions are available to provide handling of files recognised by
extension, for example to dispatch a file <TT>text.ps</TT> when executed as a
command to an appropriate viewer.
</P><P>

<DL COMPACT>
<DT><TT>zsh-mime-setup [-flv]</TT>
<DD><DT><TT>zsh-mime-handler</TT>
<DD>These two functions use the files <TT>~/.mime.types</TT> and <TT>/etc/mime.types</TT>,
which associate types and extensions, as well as <TT>~/.mailcap</TT> and
<TT>/etc/mailcap</TT> files, which associate types and the programs that
handle them.  These are provided on many systems with the Multimedia
Internet Mail Extensions.
<P>

To enable the system, the function <TT>zsh-mime-setup</TT> should be
autoloaded and run.  This allows files with extensions to be treated
as executable; such files be completed by the function completion system.
The function <TT>zsh-mime-handler</TT> should not need to be called by the
user.
</P><P>

The system works by setting up suffix aliases with `<TT>alias -s</TT>'.
Suffix aliases already installed by the user will not be overwritten.
</P><P>

Repeated calls to <TT>zsh-mime-setup</TT> do not override the existing
mapping between suffixes and executable files unless the option <TT>-f</TT>
is given.  Note, however, that this does not override existing suffix
aliases assigned to handlers other than <TT>zsh-mime-handler</TT>.
Calling <TT>zsh-mime-setup</TT> with the option <TT>-l</TT> lists the existing
mapping without altering it.  Calling <TT>zsh-mime-setup</TT> with the option
<TT>-v</TT> causes verbose output to be shown during the setup operation.
</P><P>

The system respects the <TT>mailcap</TT> flags <TT>needsterminal</TT> and
<TT>copiousoutput</TT>, see man page mailcap(4).
</P><P>

The functions use the following styles, which are defined with the
<TT>zstyle</TT> builtin command (<A HREF="zsh_21.html#SEC182">21.31 The zsh/zutil Module</A>).  They should be defined
before <TT>zsh-mime-setup</TT> is run.  The contexts used all
start with <TT>:mime:</TT>, with additional components in some cases.
It is recommended that a trailing <TT>*</TT> (suitably quoted) be appended
to style patterns in case the system is extended in future.  Some
examples are given below.
<DL COMPACT>
<DT>mime-types
<DD>A list of files in the format of <TT>~/.mime.types</TT> and
<TT>/etc/mime.types</TT> to be read during setup, replacing the default list
which consists of those two files.  The context is <TT>:mime:</TT>.
<P>

<DT>mailcap
<DD>A list of files in the format of <TT>~/.mailcap</TT> and
<TT>/etc/mailcap</TT> to be read during setup, replacing the default list
which consists of those two files.  The context is <TT>:mime:</TT>.
<P>

<DT>handler
<DD>Specifies a handler for a suffix; the suffix is given by the context as
<TT>:mime:.</TT><VAR>suffix</VAR><TT>:</TT>, and the format of the handler is exactly
that in <TT>mailcap</TT>.  Note in particular the `<TT>.</TT>' and trailing colon
to distinguish this use of the context.  This overrides any handler
specified by the <TT>mailcap</TT> files.  If the handler requires a terminal,
the <TT>flags</TT> style should be set to include the word <TT>needsterminal</TT>,
or if the output is to be displayed through a pager (but not if the
handler is itself a pager), it should include <TT>copiousoutput</TT>.
<P>

<DT>flags
<DD>Defines flags to go with a handler; the context is as for the
<TT>handler</TT> style, and the format is as for the flags in <TT>mailcap</TT>.
<P>

<DT>pager
<DD>If set, will be used instead of <TT>$PAGER</TT> or <TT>more</TT> to handle
suffixes where the <TT>copiousoutput</TT> flag is set.  The context is
as for <TT>handler</TT>, i.e. <TT>:mime:.</TT><VAR>suffix</VAR><TT>:</TT> for handling
a file with the given <VAR>suffix</VAR>.
<P>

</DL>
<P>

Examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle ':mime:*' mailcap ~/.mailcap /usr/local/etc/mailcap
zstyle ':mime:.txt' handler less %s
zstyle ':mime:.txt' flags needsterminal
</pre></td></tr></table></P><P>

When <TT>zsh-mime-setup</TT> is subsequently run, it will look for
<TT>mailcap</TT> entries in the two files given.  Files of suffix <TT>.txt</TT>
will be handled by running `<TT>less</TT> <VAR>file.txt</VAR>'.  The flag
<TT>needsterminal</TT> is set to show that this program must run attached to a
terminal.
</P><P>

As there are several steps to dispatching a command, the following
should be checked if attempting to execute a file by extension
<TT>.</TT><VAR>ext</VAR> does not have the expected effect.
starteit()
eit()(
The command `<TT>alias -s</TT> <VAR>ext</VAR>' should show
`<TT>ps=zsh-mime-handler</TT>'.  If it shows something else, another suffix
alias was already installed and was not overwritten.  If it shows
nothing, no handler was installed:  this is most likely because no
handler was found in the <TT>.mime.types</TT> and <TT>mailcap</TT> combination for
<TT>.ext</TT> files.  In that case, appropriate handling should be added to
<TT>~/.mime.types</TT> and <TT>mailcap</TT>.
)
eit()(
If the extension is handled by <TT>zsh-mime-handler</TT> but the file is
not opened correctly, either the handler defined for the type is
incorrect, or the flags associated with it are in appropriate.  Running
<TT>zsh-mime-setup -l</TT> will show the handler and, if there are any, the
flags.  A <TT>%s</TT> in the handler is replaced by the file (suitably quoted
if necessary).  Check that the handler program listed lists and can
be run in the way shown.  Also check that the flags <TT>needsterminal</TT> or
<TT>copiousoutput</TT> are set if the handler needs to be run under a
terminal; the second flag is used if the output should be sent to a pager.
An example of a suitable <TT>mailcap</TT> entry for such a program is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>text/html; /usr/bin/lynx '%s'; needsterminal
</pre></td></tr></table>)
endeit()
</P><P>

<DT><TT>pick-web-browser</TT>
<DD>This function is separate from the two MIME functions described above
and can be assigned directly to a suffix:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>autoload -U pick-web-browser
alias -s html=pick-web-browser
</pre></td></tr></table></P><P>

It is provided as an intelligent front end to dispatch a web browser.
It will check if an X Windows display is available, and if so
if there is already a browser running which can accept a remote
connection.  In that case, the file will be displayed in that browser;
you should check explicitly if it has appeared in the running browser's
window.  Otherwise, it will start a new browser according to a builtin
set of preferences.
</P><P>

Alternatively, <TT>pick-web-browser</TT> can be run as a zsh script.
</P><P>

Two styles are available to customize the choice of browsers:
<TT>x-browsers</TT> when running under the X Windows System, and
<TT>tty-browsers</TT> otherwise.  These are arrays in decreasing order
of preference consiting of the command name under which to start the
browser.  They are looked up in the context <TT>:mime:</TT> (which may
be extended in future, so appending `<TT>*</TT>' is recommended).  For
example,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle ':mime:*' x-browsers opera konqueror netscape
</pre></td></tr></table></P><P>

specifies that <TT>pick-web-browser</TT> should first look for a runing
instance of Opera, Konqueror or Netscape, in that order, and if it
fails to find any should attempt to start Opera.
</P><P>

</DL>
<P>

<A NAME="Other Functions"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC229"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC228"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC230"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 24.6 Other Functions </H2>
<!--docid::SEC229::-->
<P>

There are a large number of helpful functions in the <TT>Functions/Misc</TT>
directory of the zsh distribution.  Most are very simple and do not
require documentation here, but a few are worthy of special mention.
</P><P>

</P><P>

<HR SIZE="6">
<A NAME="SEC230"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC229"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC231"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.6.1 Descriptions </H3>
<!--docid::SEC230::-->
<P>

<DL COMPACT>
<A NAME="IDX1710"></A>
<DT><TT>colors</TT>
<DD>This function initializes several associative arrays to map color names to
(and from) the ANSI standard eight-color terminal codes.  These are used
by the prompt theme system (<A HREF="zsh_24.html#SEC222">24.3 Prompt Themes</A>).  You seldom should need to run
<TT>colors</TT> more than once.
<P>

The eight base colors are: black, red, green, yellow, blue, magenta, cyan,
and white.  Each of these has codes for foreground and background.  In
addition there are eight intensity attributes: bold, faint, standout,
underline, blink, reverse, and conceal.  Finally, there are six codes used
to negate attributes: none (reset all attributes to the defaults), normal
(neither bold nor faint), no-standout, no-underline, no-blink, and
no-reverse.
</P><P>

Some terminals do not support all combinations of colors and intensities.
</P><P>

The associative arrays are:
</P><P>

<DL COMPACT>
<DT>color
<DD><DT>colour
<DD>Map all the color names to their integer codes, and integer codes to the
color names.  The eight base names map to the foreground color codes, as
do names prefixed with `<TT>fg-</TT>', such as `<TT>fg-red</TT>'.  Names prefixed
with `<TT>bg-</TT>', such as `<TT>bg-blue</TT>', refer to the background codes.  The
reverse mapping from code to color yields base name for foreground codes
and the <TT>bg-</TT> form for backgrounds.
<P>

Although it is a misnomer to call them `colors', these arrays also map the
other fourteen attributes from names to codes and codes to names.
</P><P>

<DT>fg
<DD><DT>fg_bold
<DD><DT>fg_no_bold
<DD>Map the eight basic color names to ANSI terminal escape sequences that set
the corresponding foreground text properties.  The <TT>fg</TT> sequences change
the color without changing the eight intensity attributes.
<P>

<DT>bg
<DD><DT>bg_bold
<DD><DT>bg_no_bold
<DD>Map the eight basic color names to ANSI terminal escape sequences that set
the corresponding background properties.  The <TT>bg</TT> sequences change the
color without changing the eight intensity attributes.
<P>

</DL>
<P>

In addition, the scalar parameters <TT>reset_color</TT> and <TT>bold_color</TT> are
set to the ANSI terminal escapes that turn off all attributes and turn on
bold intensity, respectively.
</P><P>

<A NAME="IDX1711"></A>
<DT><TT>fned</TT> <VAR>name</VAR>
<DD>Same as <TT>zed -f</TT>.  This function does not appear in the zsh
distribution, but can be created by linking <TT>zed</TT> to the name <TT>fned</TT>
in some directory in your <TT>fpath</TT>.
<P>

<A NAME="IDX1712"></A>
<DT><TT>is-at-least</TT> <VAR>needed</VAR> [ <VAR>present</VAR> ]
<DD>Perform a greater-than-or-equal-to comparison of two strings having the
format of a zsh version number; that is, a string of numbers and text with
segments separated by dots or dashes.  If the <VAR>present</VAR> string is not
provided, <TT>$ZSH_VERSION</TT> is used.  Segments are paired left-to-right in
the two strings with leading non-number parts ignored.  If one string has
fewer segments than the other, the missing segments are considered zero.
<P>

This is useful in startup files to set options and other state that are
not available in all versions of zsh.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>is-at-least 3.1.6-15 &#38;&#38; setopt NO_GLOBAL_RCS
is-at-least 3.1.0 &#38;&#38; setopt HIST_REDUCE_BLANKS
is-at-least 2.6-17 || print "You can't use is-at-least here."
</pre></td></tr></table></P><P>

<A NAME="IDX1713"></A>
<DT><TT>nslookup</TT> [ <VAR>arg</VAR> ... ]
<DD>This wrapper function for the <TT>nslookup</TT> command requires the
<TT>zsh/zpty</TT> module (see
<A HREF="zsh_21.html#SEC180">21.29 The zsh/zpty Module</A>).  It behaves exactly like the standard <TT>nslookup</TT>
except that it provides customizable prompts (including a right-side
prompt) and completion of nslookup commands, host names, etc. (if you use
the function-based completion system).  Completion styles may be set with
the context prefix `<TT>:completion:nslookup</TT>'.
<P>

See also the <TT>pager</TT>, <TT>prompt</TT> and <TT>rprompt</TT> styles below.
</P><P>

<DT><TT>run-help</TT>
<DD>See `Accessing On-Line Help'
(<A HREF="zsh_24.html#SEC217">24.2 Utilities</A>).
<P>

<DT><TT>tetris</TT>
<DD>Zsh was once accused of not being as complete as Emacs,
because it lacked a Tetris game.  This function was written to
refute this vicious slander.
<P>

This function must be used as a ZLE widget:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>autoload -U tetris
zle -N tetris
bindkey <VAR>keys</VAR> tetris
</pre></td></tr></table></P><P>

To start a game, execute the widget by typing the <VAR>keys</VAR>.  Whatever command
line you were editing disappears temporarily, and your keymap is also
temporarily replaced by the Tetris control keys.  The previous editor state
is restored when you quit the game (by pressing `<TT>q</TT>') or when you lose.
</P><P>

If you quit in the middle of a game, the next invocation of the <TT>tetris</TT>
widget will continue where you left off.  If you lost, it will start a new
game.
</P><P>

<A NAME="IDX1714"></A>
<DT><TT>zcalc</TT> [ <VAR>expression</VAR> ... ]
<DD>A reasonably powerful calculator based on zsh's arithmetic evaluation
facility.  The syntax is similar to that of formulae in most programming
languages; see
<A HREF="zsh_10.html#SEC38">10. Arithmetic Evaluation</A> for details.  The mathematical
library <TT>zsh/mathfunc</TT> will be loaded if it is available; see
<A HREF="zsh_21.html#SEC154">21.13 The zsh/mathfunc Module</A>.  The mathematical functions
correspond to the raw system libraries, so trigonometric functions are
evaluated using radians, and so on.
<P>

Each line typed is evaluated as an expression.  The prompt shows a number,
which corresponds to a positional parameter where the result of that
calculation is stored.  For example, the result of the calculation on the
line preceded by `<TT>4&#62; </TT>' is available as <TT>$4</TT>.  Full command line
editing, including the history of previous calculations, is available; the
history is saved in the file <TT>~/.zcalc_history</TT>.  To exit, enter a blank
line or type `<TT>q</TT>' on its own.
</P><P>

If arguments are given to <TT>zcalc</TT> on start up, they are used to prime the
first few positional parameters.  A visual indication of this is given when
the calculator starts.
</P><P>

The constants <TT>PI</TT> (3.14159...) and <TT>E</TT> (2.71828...) are provided.
Parameter assignment is possible, but note that all parameters will be put
into the global namespace.
</P><P>

An extra facility is provided for changing the default output base.  Use,
for example, `<TT>[#16]</TT>' to display hexadecimal output preceded by an
indication of the base, or `<TT>[##16]</TT>' just to display the raw number in
the given base.  Bases themselves are always specified in decimal.
`<TT>[#]</TT>' restores the normal output format.
</P><P>

The output base can be initialised by passing the option `<TT>-#</TT><VAR>base</VAR>',
for example `<TT>zcalc -#16</TT>' (the `<TT>#</TT>' may have to be quoted, depending
on the globbing options set).
</P><P>

The prompt is configurable via the parameter <TT>ZCALCPROMPT</TT>, which
undergoes standard prompt expansion.  The index of the current entry is
stored locally in the first element of the array <TT>psvar</TT>, which can be
referred to in <TT>ZCALCPROMPT</TT> as `<TT>%1v</TT>'.  The default prompt is
`<TT>%1v&#62; </TT>'.
</P><P>

See the comments in the function for a few extra tips.
</P><P>

<A NAME="IDX1715"></A>
<DT><TT>zed</TT> [ <TT>-f</TT> ] <VAR>name</VAR>
<DD>This function uses the ZLE editor to edit a file or function.  It rebinds
the return key to insert a line break, and adds bindings for `<TT>^X^W</TT>' in
the <TT>emacs</TT> keymap and `<TT>ZZ</TT>' in the <TT>vicmd</TT> keymap to accept (and
therefore write, in the case of a file) the edited file or function.
Keybindings are otherwise the standard ones; completion is available, and
styles may be set with the context prefix `<TT>:completion:zed</TT>'.
<P>

Only one <VAR>name</VAR> argument is recognized (additional arguments are
ignored).  If the <TT>-f</TT> option is given, the name is taken to be that of
a function; if the function is marked for autoloading, <TT>zed</TT> searches
for it in the <TT>fpath</TT> and loads it.  Note that functions edited this way
are installed into the current shell, but <EM>not</EM> written back to the
autoload file.
</P><P>

Without <TT>-f</TT>, <VAR>name</VAR> is the path name of the file to edit, which need
not exist; it is created on write, if necessary.
</P><P>

<A NAME="IDX1716"></A>
<A NAME="IDX1717"></A>
<DT><TT>zcp</TT> [ <TT>-finqQvwW</TT> ] <VAR>srcpat</VAR> <VAR>dest</VAR>
<DD><DT><TT>zln</TT> [ <TT>-finqQsvwW</TT> ] <VAR>srcpat</VAR> <VAR>dest</VAR>
<DD>Same as <TT>zmv -C</TT> and <TT>zmv -L</TT>, respectively.  These functions do not
appear in the zsh distribution, but can be created by linking <TT>zmv</TT> to
the names <TT>zcp</TT> and <TT>zln</TT> in some directory in your <TT>fpath</TT>.
<P>

<DT><TT>zkbd</TT>
<DD>See `Keyboard Definition'
(<A HREF="zsh_24.html#SEC217">24.2 Utilities</A>).
<P>

<A NAME="IDX1718"></A>
<DT><TT>zmv</TT> [ <TT>-finqQsvwW</TT> ] [ -C | -L | -M | -p <VAR>program</VAR> ] [ -o <VAR>optstring</VAR> ] <VAR>srcpat</VAR> <VAR>dest</VAR>
<DD>Move (usually, rename) files matching the pattern <VAR>srcpat</VAR> to
corresponding files having names of the form given by <VAR>dest</VAR>, where
<VAR>srcpat</VAR> contains parentheses surrounding patterns which will be
replaced in turn by $1, $2, ... in <VAR>dest</VAR>.  For example,
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zmv '(*).lis' '$1.txt'
</pre></td></tr></table></P><P>

renames `<TT>foo.lis</TT>' to `<TT>foo.txt</TT>', `<TT>my.old.stuff.lis</TT>' to
`<TT>my.old.stuff.txt</TT>', and so on.
</P><P>

The pattern is always treated as an <TT>EXTENDED_GLOB</TT> pattern.  Any file
whose name is not changed by the substitution is simply ignored.  Any
error (a substitution resulted in an empty string, two substitutions gave
the same result, the destination was an existing regular file and <TT>-f</TT>
was not given) causes the entire function to abort without doing anything.
</P><P>

Options:
</P><P>

<DL COMPACT>
<DT><TT>-f</TT>
<DD>Force overwriting of destination files.  Not currently
passed down to the <TT>mv</TT>/<TT>cp</TT>/<TT>ln</TT> command due to vagaries of
implementations (but you can use <TT>-o-f</TT> to do that).
<DT><TT>-i</TT>
<DD>Interactive: show each line to be executed and ask the user
whether to execute it.  `Y' or `y' will execute it, anything else will
skip it.  Note that you just need to type one character.
<DT><TT>-n</TT>
<DD>No execution: print what would happen, but don't do it.
<DT><TT>-q</TT>
<DD>Turn bare glob qualifiers off: now assumed by default, so
this has no effect.
<DT><TT>-Q</TT>
<DD>Force bare glob qualifiers on.  Don't turn this on unless
you are actually using glob qualifiers in a pattern.
<DT><TT>-s</TT>
<DD>Symbolic, passed down to <TT>ln</TT>; only works with <TT>-L</TT>.
<DT><TT>-v</TT>
<DD>Verbose: print each command as it's being executed.
<DT><TT>-w</TT>
<DD>Pick out wildcard parts of the pattern, as described above,
and implicitly add parentheses for referring to them.
<DT><TT>-W</TT>
<DD>Just like <TT>-w</TT>, with the addition of turning wildcards in
the replacement pattern into sequential ${1} .. ${N} references.
<DT><TT>-C</TT>
<DD><DT><TT>-L</TT>
<DD><DT><TT>-M</TT>
<DD>Force <TT>cp</TT>, <TT>ln</TT> or <TT>mv</TT>, respectively, regardless of
the name of the function.
<DT><TT>-p</TT> <VAR>program</VAR>
<DD>Call <VAR>program</VAR> instead of <TT>cp</TT>, <TT>ln</TT> or
<TT>mv</TT>.  Whatever it does, it should at least understand the form
<TABLE><tr><td>&nbsp;</td><td class=example><pre><VAR>program</VAR> <TT>-</TT><TT>-</TT> <VAR>oldname</VAR> <VAR>newname</VAR>
</pre></td></tr></table>where <VAR>oldname</VAR> and <VAR>newname</VAR> are filenames generated by <TT>zmv</TT>.
<DT><TT>-o</TT> <VAR>optstring</VAR>
<DD>The <VAR>optstring</VAR> is split into words and
passed down verbatim to the <TT>cp</TT>, <TT>ln</TT> or <TT>mv</TT> command called to
perform the work.  It should probably begin with a `<TT>-</TT>'.
</DL>
<P>

For more complete examples and other implementation details, see the
<TT>zmv</TT> source file, usually located in one of the directories named in
your <TT>fpath</TT>, or in <TT>Functions/Misc/zmv</TT> in the zsh distribution.
</P><P>

<DT><TT>zrecompile</TT>
<DD>See `Recompiling Functions'
(<A HREF="zsh_24.html#SEC217">24.2 Utilities</A>).
<P>

<A NAME="IDX1719"></A>
<DT><TT>zstyle+</TT> <VAR>context</VAR> <VAR>style</VAR> <VAR>value</VAR> [ + <VAR>subcontext</VAR> <VAR>style</VAR> <VAR>value</VAR> ... ]
<DD>This makes defining styles a bit simpler by using a single `<TT>+</TT>' as a
special token that allows you to append a context name to the previously
used context name.  Like this:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>zstyle+ ':foo:bar' style1 value1 \ 
      + ':baz'     style2 value2 \ 
      + ':frob'    style3 value3
</pre></td></tr></table></P><P>

This defines `style1' with `value1' for the context <TT>:foo:bar</TT> as usual,
but it also defines `style2' with `value2' for the context
<TT>:foo:bar:baz</TT> and `style3' with `value3' for <TT>:foo:bar:frob</TT>.  Any
<VAR>subcontext</VAR> may be the empty string to re-use the first context
unchanged.
</P><P>

</DL>
<P>

</P><P>

<HR SIZE="6">
<A NAME="SEC231"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC230"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 24.6.2 Styles </H3>
<!--docid::SEC231::-->
<P>

<DL COMPACT>
<A NAME="IDX1720"></A>
<DT><TT>insert-tab</TT>
<DD>The <TT>zed</TT> function <EM>sets</EM> this style in context `<TT>:completion:zed:*</TT>'
to turn off completion when <TT>TAB</TT> is typed at the beginning of a line.
You may override this by setting your own value for this context and style.
<P>

<A NAME="IDX1721"></A>
<DT><TT>pager</TT>
<DD>The <TT>nslookup</TT> function looks up this style in the context
`<TT>:nslookup</TT>' to determine the program used to display output that does
not fit on a single screen.
<P>

<A NAME="IDX1722"></A>
<A NAME="IDX1723"></A>
<DT><TT>prompt</TT>
<DD><DT><TT>rprompt</TT>
<DD>The <TT>nslookup</TT> function looks up this style in the context
`<TT>:nslookup</TT>' to set the prompt and the right-side prompt, respectively.
The usual expansions for the <TT>PS1</TT> and <TT>RPS1</TT> parameters may be used
(see
<A HREF="zsh_12.html#SEC40">12. Prompt Expansion</A>).
<P>

</DL>
<A NAME="Concept Index"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_24.html#SEC215"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_25.html#SEC232">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="zsh_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Peter Stephenson</I> on <I>March, 19  2004</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
